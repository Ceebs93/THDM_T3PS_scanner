! This file is part of HiggsBounds
!
!
! XS_HW_SM,XS_HZ_SM,XS_gg_H_SM,XS_bb_H_SM,XS_vbf:_H_SM
! in units of fb
! functions are fitted to data
! downloaded from http://maltoni.home.cern.ch/maltoni/TeV4LHC/bbh-tev_ed.dat
! on Thursday 10th April 2008
! data has range 100 to 300 GeV
!
! functions XS_tev_bg_Hb_SM,XS_tev_bg_Hb_c1_SM,XS_tev_bg_Hb_c2_SM were generated by Oliver Brein
!
! on Tuesday 22nd March 2011
! functions XS_lhc7_gg_H_SM,XS_lhc7_HW_SM,XS_lhc7_HZ_SM,XS_lhc7_vbf_SM,XS_lhc7_ttH_SM were generated by Tim Stefaniak
!
! Summer 2012
! Functions for 8 TeV added by OS
!
!******************************************************

module theory_XS_SM_functions

    use interpolate
    use S95tables_type1
    use usefulbits, only: div

    implicit none

    type(table1), allocatable :: XSSM(:)
! For the WH and ZH approximation from effective couplings:
    type(table1), allocatable :: VHcoeff(:)
! For the full ZH approximation:
    type(table1), allocatable :: ZHcoeff(:)
! For the charged Higgs cross section
    type(table1), allocatable :: tHccoeff(:)
    ! index: Tev, LHC7, LHC8, LHC13
    integer :: Ncollider = 4

! this must be narrower than range of
! XS_bg_Hb_SM,XS_bg_Hb_c1_SM,XS_bg_Hb_c2_SM ([10:400])
! XS_tev_gg_H_SM (currently [50:350])
! theory_tevSfunctions (currently [50:400])
!have temporarily set tevXS_SM_functions_xmax to 361, even though this is
!outside the range of XS_tev_gg_H_SM, because the very high Mh are only used for
!tev%XS_Hb_c1_SM at the moment, but we need to be careful (we should calculate XS_tev_gg_H_SM for a bigger range
!as soon as possible)

!  double precision :: tevXS_SM_functions_xmin=60.0D0
!  double precision :: tevXS_SM_functions_xmax=361.0D0
!
!  double precision :: lhc7XS_SM_functions_xmin=79.0D0
!  double precision :: lhc7XS_SM_functions_xmax=1001.0D0
!
!  double precision :: lhc8XS_SM_functions_xmin=45.0D0
!  double precision :: lhc8XS_SM_functions_xmax=1120.0D0

! NEW BOUNDARIES:
    double precision :: tevXS_SM_functions_xmin = 60.0D0
    double precision :: tevXS_SM_functions_xmax = 361.0D0

    double precision :: lhc7XS_SM_functions_xmin = 10.0D0
    double precision :: lhc7XS_SM_functions_xmax = 3000.0D0

    double precision :: lhc8XS_SM_functions_xmin = 10.0D0
    double precision :: lhc8XS_SM_functions_xmax = 3000.0D0

    double precision :: lhc13XS_SM_functions_xmin = 10.0D0
    double precision :: lhc13XS_SM_functions_xmax = 3000.0D0

contains

    !  NEW ROUTINES FOR HB-5  !

    !******************************************************
    subroutine setup_XSSM
        ! reads in the Standard Model Cross Sections from files,
        ! currently using the YR4 predictions
        !******************************************************
        use install_data, only: pathname, pathname_length
        use usefulbits, only: file_id_common2
        implicit none
        !------------------------------------internal
        integer :: x, xbeg, xend
        character(len=100), allocatable :: filename(:)
        character(LEN=pathname_length + 150) :: fullfilename
        integer :: ios
        !--------------------------------------------

        allocate (XSSM(12))

        xbeg = lbound(XSSM, dim=1)
        xend = ubound(XSSM, dim=1)

        allocate (filename(xbeg:xend))
        x = xbeg - 1

! NOTE: The %id placeholder is abused to specify the number of columns in the file

        x = x + 1
        XSSM(x)%xmin = 10.0D0
        XSSM(x)%xmax = 3000.0D0
        XSSM(x)%sep = 5.0D0
        XSSM(x)%id = 4
        filename(x) = 'YR4/BSM_XS_7_ggHVBFbbH.dat'

        x = x + 1
        XSSM(x)%xmin = 10.0D0
        XSSM(x)%xmax = 2000.0D0
        XSSM(x)%sep = 5.0D0
        XSSM(x)%id = 3
        filename(x) = 'YR4/BSM_XS_7_WHZH.dat'

        x = x + 1
        XSSM(x)%xmin = 120.0D0
        XSSM(x)%xmax = 130.0D0
        XSSM(x)%sep = 0.1D0
        XSSM(x)%id = 9
!   filename(x)='YR4/SM_XS_7_all.dat'
        filename(x) = 'YR4/SM_XS_7_all_YR4update.dat'

        x = x + 1
        XSSM(x)%xmin = 10.0D0
        XSSM(x)%xmax = 3000.0D0
        XSSM(x)%sep = 5.0D0
        XSSM(x)%id = 4
        filename(x) = 'YR4/BSM_XS_8_ggHVBFbbH.dat'

        x = x + 1
        XSSM(x)%xmin = 10.0D0
        XSSM(x)%xmax = 2000.0D0
        XSSM(x)%sep = 5.0D0
        XSSM(x)%id = 3
        filename(x) = 'YR4/BSM_XS_8_WHZH.dat'

        x = x + 1
        XSSM(x)%xmin = 10.0D0
        XSSM(x)%xmax = 3000.0D0
        XSSM(x)%sep = 5.0D0
        XSSM(x)%id = 2
        filename(x) = 'YR4/BSM_XS_8_ttH.dat'

        x = x + 1
        XSSM(x)%xmin = 120.0D0
        XSSM(x)%xmax = 130.0D0
        XSSM(x)%sep = 0.1D0
        XSSM(x)%id = 9
!   filename(x)='YR4/SM_XS_8_all.dat'
        filename(x) = 'YR4/SM_XS_8_all_YR4update.dat'

        x = x + 1
        XSSM(x)%xmin = 10.0D0
        XSSM(x)%xmax = 3000.0D0
        XSSM(x)%sep = 5.0D0
        XSSM(x)%id = 4
        filename(x) = 'YR4/BSM_XS_13_ggHVBFbbH.dat'
!  filename(x)='YR4/BSM_XS_13_ggHVBFbbH_YR4update.dat'

        x = x + 1
        XSSM(x)%xmin = 10.0D0
        XSSM(x)%xmax = 2000.0D0
        XSSM(x)%sep = 5.0D0
        XSSM(x)%id = 3
        filename(x) = 'YR4/BSM_XS_13_WHZH.dat'

        x = x + 1
        XSSM(x)%xmin = 10.0D0
        XSSM(x)%xmax = 3000.0D0
        XSSM(x)%sep = 5.0D0
        XSSM(x)%id = 2
        filename(x) = 'YR4/BSM_XS_13_ttH.dat'

        x = x + 1
        XSSM(x)%xmin = 10.0D0
        XSSM(x)%xmax = 3000.0D0
        XSSM(x)%sep = 5.0D0
        XSSM(x)%id = 3
        filename(x) = 'YR4/BSM_XS_13_tH.dat'

        x = x + 1
        XSSM(x)%xmin = 120.0D0
        XSSM(x)%xmax = 130.0D0
        XSSM(x)%sep = 0.1D0
        XSSM(x)%id = 9
!   filename(x)='YR4/SM_XS_13_all.dat'
        filename(x) = 'YR4/SM_XS_13_all_YR4update.dat'

        ! checks we've filled the whole array
        if (x .ne. xend) then
            stop 'error in setup_XSSM (a)'
        end if

        ! do loop to read in S95 tables
        do x = xbeg, xend
            XSSM(x)%nx = nint((XSSM(x)%xmax - XSSM(x)%xmin)/XSSM(x)%sep) + 1
            allocate (XSSM(x)%dat(XSSM(x)%nx, XSSM(x)%id - 1))
        end do

        open (file_id_common2, file=trim(adjustl(pathname))//'Theory_tables/'// &
              'XSSM.binary', form='unformatted')

        read (file_id_common2, iostat=ios) XSSM(xbeg)%dat

        if (ios .eq. 0) then

            do x = xbeg + 1, xend
                read (file_id_common2) XSSM(x)%dat
            end do

        else
            rewind (file_id_common2)
            do x = xbeg, xend
                fullfilename = trim(adjustl(pathname))//'Theory_tables/' &
                               //trim(filename(x))

                call read_tabletype1(XSSM(x), 0, XSSM(x)%id, fullfilename)
                write (file_id_common2) XSSM(x)%dat
            end do
        end if
        close (file_id_common2)
        deallocate (filename)

!****************************************************
! Read in the WH/ZH coefficients for the effective coupling approximation
!****************************************************
        allocate (VHcoeff(20))

        xbeg = lbound(VHcoeff, dim=1)
        xend = ubound(VHcoeff, dim=1)

        allocate (filename(xbeg:xend))
        x = xbeg - 1

! NOTE: The %id placeholder is abused to specify the number of columns in the file

! Tevatron
        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 1850.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/Teva__coefficients_WH_NOEW.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 1850.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/Teva__coefficients_WH.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 1850.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/Teva__coefficients_ZH_NOEW.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 1850.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/Teva__coefficients_ZH.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 1850.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/Teva__coefficients_ZH_CPodd.dat'

! LHC7

        x = x + 1
        VHcoeff(x)%xmin = 2.0D0
        VHcoeff(x)%xmax = 2950.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC7__coefficients_WH_NOEW.dat'

        x = x + 1
        VHcoeff(x)%xmin = 2.0D0
        VHcoeff(x)%xmax = 2950.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC7__coefficients_WH.dat'

        x = x + 1
        VHcoeff(x)%xmin = 2.0D0
        VHcoeff(x)%xmax = 2950.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC7__coefficients_ZH_NOEW.dat'

        x = x + 1
        VHcoeff(x)%xmin = 2.0D0
        VHcoeff(x)%xmax = 2950.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC7__coefficients_ZH.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 1850.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC7__coefficients_ZH_CPodd.dat'

! LHC8

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 2950.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC8__coefficients_WH_NOEW.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 2950.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC8__coefficients_WH.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 2950.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC8__coefficients_ZH_NOEW.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 2950.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC8__coefficients_ZH.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 1850.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC8__coefficients_ZH_CPodd.dat'

! LHC13
        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 2950.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC13__coefficients_WH_NOEW.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 2950.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC13__coefficients_WH.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 2950.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC13__coefficients_ZH_NOEW.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 2950.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC13__coefficients_ZH.dat'

        x = x + 1
        VHcoeff(x)%xmin = 1.0D0
        VHcoeff(x)%xmax = 1850.0D0
        VHcoeff(x)%sep = 1.0D0
        VHcoeff(x)%id = 8
        filename(x) = 'VH_coefficients/LHC8__coefficients_ZH_CPodd.dat'

        ! checks we've filled the whole array
        if (x .ne. xend) then
            stop 'error in setup_XSSM (b)'
        end if

        ! do loop to read in S95 tables
        do x = xbeg, xend
            VHcoeff(x)%nx = nint((VHcoeff(x)%xmax - VHcoeff(x)%xmin)/VHcoeff(x)%sep) + 1
            allocate (VHcoeff(x)%dat(VHcoeff(x)%nx, VHcoeff(x)%id - 1))
        end do

        open (file_id_common2, file=trim(adjustl(pathname))//'Theory_tables/'// &
              'VHcoeff.binary', form='unformatted')

        read (file_id_common2, iostat=ios) VHcoeff(xbeg)%dat

        if (ios .eq. 0) then

            do x = xbeg + 1, xend
                read (file_id_common2) VHcoeff(x)%dat
            end do

        else
            rewind (file_id_common2)
            do x = xbeg, xend
                fullfilename = trim(adjustl(pathname))//'Theory_tables/' &
                               //trim(filename(x))
!      write(*,*) "Reading in "//fullfilename
                call read_tabletype1(VHcoeff(x), 1, VHcoeff(x)%id, fullfilename)
                write (file_id_common2) VHcoeff(x)%dat
            end do
        end if
        close (file_id_common2)
        deallocate (filename)

!****************************************************
! Read in the full ZH coefficients for the effective coupling approximation
! (TS/DD 2018-08-23)
!****************************************************
        allocate (ZHcoeff(Ncollider))

        xbeg = lbound(ZHcoeff, dim=1)
        xend = ubound(ZHcoeff, dim=1)

        allocate (filename(xbeg:xend))
        x = xbeg - 1

! NOTE: The %id placeholder is abused to specify the number of columns in the file

        x = x + 1
        ZHcoeff(x)%xmin = 1.0D0
        ZHcoeff(x)%xmax = 500.0D0
        ZHcoeff(x)%sep = 1.0D0
        ZHcoeff(x)%id = 133
        filename(x) = 'VH_coefficients/Teva_fulltable.dat'

        x = x + 1
        ZHcoeff(x)%xmin = 1.0D0
        ZHcoeff(x)%xmax = 4999.0D0
        ZHcoeff(x)%sep = 1.0D0
        ZHcoeff(x)%id = 133
        filename(x) = 'VH_coefficients/LHC7_fulltable.dat'

        x = x + 1
        ZHcoeff(x)%xmin = 1.0D0
        ZHcoeff(x)%xmax = 4999.0D0
        ZHcoeff(x)%sep = 1.0D0
        ZHcoeff(x)%id = 133
        filename(x) = 'VH_coefficients/LHC8_fulltable.dat'

        x = x + 1
        ZHcoeff(x)%xmin = 1.0D0
        ZHcoeff(x)%xmax = 4999.0D0
        ZHcoeff(x)%sep = 1.0D0
        ZHcoeff(x)%id = 133
        filename(x) = 'VH_coefficients/LHC13_fulltable.dat'

        ! checks we've filled the whole array
        if (x .ne. xend) then
            stop 'error in setup_XSSM (c)'
        end if

        ! do loop to read in S95 tables
        do x = xbeg, xend
            ZHcoeff(x)%nx = nint((ZHcoeff(x)%xmax - ZHcoeff(x)%xmin)/ZHcoeff(x)%sep) + 1
            allocate (ZHcoeff(x)%dat(ZHcoeff(x)%nx, ZHcoeff(x)%id - 1))
        end do

        open (file_id_common2, file=trim(adjustl(pathname))//'Theory_tables/'// &
              'ZHcoeff.binary', form='unformatted')

        read (file_id_common2, iostat=ios) ZHcoeff(xbeg)%dat

        if (ios .eq. 0) then
            do x = xbeg + 1, xend
                read (file_id_common2) ZHcoeff(x)%dat
            end do

        else
            rewind (file_id_common2)
            do x = xbeg, xend
                fullfilename = trim(adjustl(pathname))//'Theory_tables/' &
                               //trim(filename(x))
!       write(*,*) "Reading in "//fullfilename
                call read_tabletype1(ZHcoeff(x), 1, ZHcoeff(x)%id, fullfilename)
                write (file_id_common2) ZHcoeff(x)%dat
            end do
        end if
        close (file_id_common2)

        deallocate (filename)
! -----------------------
        ! read in the charged Higgs cross section coefficients
        allocate (tHccoeff(1))
        allocate (filename(1))

        tHccoeff(1)%xmin = 145.0D0
        tHccoeff(1)%xmax = 2000.0D0
        tHccoeff(1)%sep = 5.0D0
        tHccoeff(1)%id = 4
        fullfilename = trim(adjustl(pathname))//'Theory_tables/ChargedHiggs_Cxns/LHC13_coefficients.dat'
        tHccoeff(1)%nx = nint((tHccoeff(1)%xmax - tHccoeff(1)%xmin)/tHccoeff(1)%sep) + 1
        allocate (tHccoeff(1)%dat(tHccoeff(1)%nx, tHccoeff(1)%id - 1))
        call read_tabletype1(tHccoeff(1), 1, tHccoeff(1)%id, fullfilename)

        deallocate (filename)

    end subroutine setup_XSSM

    !************************************************************
    subroutine deallocate_XSSM
        !************************************************************
        implicit none
        !-----------------------------------internal
        integer x
        !-------------------------------------------
        do x = lbound(XSSM, dim=1), ubound(XSSM, dim=1)
            deallocate (XSSM(x)%dat)
        end do

        deallocate (XSSM)

        do x = lbound(VHcoeff, dim=1), ubound(VHcoeff, dim=1)
            deallocate (VHcoeff(x)%dat)
        end do

        deallocate (VHcoeff)

        do x = lbound(ZHcoeff, dim=1), ubound(ZHcoeff, dim=1)
            deallocate (ZHcoeff(x)%dat)
        end do

        deallocate (ZHcoeff)
        deallocate (tHccoeff(1)%dat)
        deallocate (tHccoeff)

    end subroutine deallocate_XSSM
    !************************************************************

    !******************************************************
    ! New coefficient functions for HB-5 for effective coupling
    ! approximation of WH, ZH production.
    !******************************************************
    function XS_WHcoeff(x, collider, coeff_i, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        integer, intent(in) :: coeff_i
        character(LEN=5), intent(in) :: collider
        double precision :: interpol
        double precision :: XS_WHcoeff
        logical, optional :: strict
        logical, optional :: EWcorr
        integer :: iwEW, iwoEW

        if (strict) continue ! silence unused variable warning

        call testXSSM(x)

        select case (trim(adjustl(collider)))
        case ("TEV")
            iwoEW = 1
            iwEW = 2
        case ("LHC7")
            iwoEW = 6
            iwEW = 7
        case ("LHC8")
            iwoEW = 11
            iwEW = 12
        case ("LHC13")
            iwoEW = 16
            iwEW = 17
        case default
            stop 'wrong input for collider to subroutine XS_WHcoeff'
        end select

        call interpolate_tabletype1(x, VHcoeff(iwoEW), coeff_i, interpol, .True.)

        if (present(EWcorr)) then
            if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                call interpolate_tabletype1(x, VHcoeff(iwEW), coeff_i, interpol, .True.)
            end if
        end if

! else
!  interpol=badvalue
! endif

        XS_WHcoeff = interpol

    end function XS_WHcoeff

    function WH_nnlo(x, collider, ghw, ght, ghb, strict, EWcorr)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghw, ght, ghb
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        logical, optional :: EWcorr
        double precision :: WH_nnlo

        WH_nnlo = XS_WHcoeff(x, collider, 1, strict, EWcorr)*ght**2.0D0 + &
                  XS_WHcoeff(x, collider, 2, strict, EWcorr)*ghb**2.0D0 + &
                  XS_WHcoeff(x, collider, 3, strict, EWcorr)*ghw**2.0D0 + &
                  XS_WHcoeff(x, collider, 4, strict, EWcorr)*ght*ghw + &
                  XS_WHcoeff(x, collider, 5, strict, EWcorr)*ghb*ghw + &
                  XS_WHcoeff(x, collider, 6, strict, EWcorr)*ght*ghb

    end function WH_nnlo

    function WH_nnlo_SM(x, collider, strict, EWcorr)
        implicit none
        double precision, intent(in) :: x
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        logical, optional :: EWcorr
        double precision :: WH_nnlo_SM

        WH_nnlo_SM = XS_WHcoeff(x, collider, 7, strict, EWcorr)

    end function WH_nnlo_SM

    !******************************************************
    function XS_ZHcoeff(x, collider, coeff_i, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        integer, intent(in) :: coeff_i
        character(LEN=5), intent(in) :: collider
        double precision :: interpol
        double precision :: XS_ZHcoeff
        logical, optional :: strict
        logical, optional :: EWcorr
        integer :: iwEW, iwoEW

        if (strict) continue ! silence unused variable warning

        call testXSSM(x)

        select case (trim(adjustl(collider)))
        case ("TEV")
            iwoEW = 3
            iwEW = 4
        case ("LHC7")
            iwoEW = 8
            iwEW = 9
        case ("LHC8")
            iwoEW = 13
            iwEW = 14
        case ("LHC13")
            iwoEW = 18
            iwEW = 19
        case default
            stop 'wrong input for collider to subroutine XS_ZHcoeff'
        end select

        call interpolate_tabletype1(x, VHcoeff(iwoEW), coeff_i, interpol, .True.)

        if (present(EWcorr)) then
            if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                call interpolate_tabletype1(x, VHcoeff(iwEW), coeff_i, interpol, .True.)
            end if
        end if

        XS_ZHcoeff = interpol

    end function XS_ZHcoeff
    !******************************************************
    function XS_ZHcoeff_CPodd(x, collider, coeff_i, strict)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        integer, intent(in) :: coeff_i
        character(LEN=5), intent(in) :: collider
        double precision :: interpol
        double precision :: XS_ZHcoeff_CPodd
        logical, optional :: strict
        integer :: i

        if (strict) continue ! silence unused variable warning

        call testXSSM(x)

        select case (trim(adjustl(collider)))
        case ("TEV")
            i = 5
        case ("LHC7")
            i = 10
        case ("LHC8")
            i = 15
        case ("LHC13")
            i = 20
        case default
            stop 'wrong input for collider to subroutine XS_ZHcoeff_CPodd'
        end select

        call interpolate_tabletype1(x, VHcoeff(i), coeff_i, interpol, .True.)

        XS_ZHcoeff_CPodd = interpol

    end function XS_ZHcoeff_CPodd
    !******************************************************
    function ZHcoeff_func(x, collider, coeff_i, strict)!,EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        integer, intent(in) :: coeff_i
        character(LEN=5), intent(in) :: collider
        double precision :: interpol
        double precision :: ZHcoeff_func
        logical, optional :: strict
        integer :: i

        if (strict) continue ! silence unused variable warning

        call testXSSM(x)

        select case (trim(adjustl(collider)))
        case ("TEV")
            i = 1
        case ("LHC7")
            i = 2
        case ("LHC8")
            i = 3
        case ("LHC13")
            i = 4
        case default
            stop 'wrong input for collider to subroutine XS_ZHcoeff_full'
        end select

! as long as only LHC13 is implemented:
!    i = 1

        call interpolate_tabletype1(x, ZHcoeff(i), coeff_i, interpol, .True.)

!    if(present(EWcorr))then
!     if(EWcorr.and.(abs(x-125.0D0).le.5.0D0)) then
!      call interpolate_tabletype1(x,VHcoeff(iwEW),coeff_i,interpol,.True.)
!     endif
!    endif

        ZHcoeff_func = interpol

    end function ZHcoeff_func
    !******************************************************
    ! Internal functions to obtain the ZH cross section
    !******************************************************
!***********************<<<<START ZH FUNCTION BLOCK >>>>>****************

    function ZH_cp0_nlo(x, collider, ghz, ght, ghb, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cp0_nlo

        ZH_cp0_nlo = ghz**2.0D0*ZHcoeff_func(x, collider, 7, strict) + &
                     ght**2.0D0*ZHcoeff_func(x, collider, 1, strict) + &
                     ght*ghz*ZHcoeff_func(x, collider, 9, strict) + &
                     ght*ghb*ZHcoeff_func(x, collider, 5, strict) + &
                     ghb**2.0D0*ZHcoeff_func(x, collider, 3, strict) + &
                     ghb*ghz*ZHcoeff_func(x, collider, 11, strict)
        ZH_cp0_nlo = ZH_cp0_nlo/1000.0D0 ! convert from fb to pb
    end function ZH_cp0_nlo

    function ZH_cp0_nlo_gg(x, collider, ghz, ght, ghb, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cp0_nlo_gg

        ZH_cp0_nlo_gg = ghz**2.0D0*ZHcoeff_func(x, collider, 37, strict) + &
                        ght**2.0D0*ZHcoeff_func(x, collider, 31, strict) + &
                        ght*ghz*ZHcoeff_func(x, collider, 39, strict) + &
                        ght*ghb*ZHcoeff_func(x, collider, 35, strict) + &
                        ghb**2.0D0*ZHcoeff_func(x, collider, 33, strict) + &
                        ghb*ghz*ZHcoeff_func(x, collider, 41, strict)
        ZH_cp0_nlo_gg = ZH_cp0_nlo_gg/1000.0D0 ! convert from fb to pb
    end function ZH_cp0_nlo_gg

    function ZH_cp0_nlo_qq(x, collider, ghz, ght, ghb, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cp0_nlo_qq

        ZH_cp0_nlo_qq = ghz**2.0D0*ZHcoeff_func(x, collider, 67, strict) + &
                        ght**2.0D0*ZHcoeff_func(x, collider, 61, strict) + &
                        ght*ghz*ZHcoeff_func(x, collider, 69, strict) + &
                        ght*ghb*ZHcoeff_func(x, collider, 65, strict) + &
                        ghb**2.0D0*ZHcoeff_func(x, collider, 63, strict) + &
                        ghb*ghz*ZHcoeff_func(x, collider, 71, strict)
        ZH_cp0_nlo_qq = ZH_cp0_nlo_qq/1000.0D0 ! convert from fb to pb
    end function ZH_cp0_nlo_qq

    function ZH_cp0_nlo_bb(x, collider, ghb, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghb
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cp0_nlo_bb

        ZH_cp0_nlo_bb = ghb**2.0D0*ZHcoeff_func(x, collider, 91, strict)
        ZH_cp0_nlo_bb = ZH_cp0_nlo_bb/1000.0D0 ! convert from fb to pb
    end function ZH_cp0_nlo_bb

    function ZH_cp0_nlo_ggqqbb(x, collider, ghz, ght, ghb, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cp0_nlo_ggqqbb

        ZH_cp0_nlo_ggqqbb = ZH_cp0_nlo_gg(x, collider, ghz, ght, ghb, strict) + &
                            ZH_cp0_nlo_qq(x, collider, ghz, ght, ghb, strict) + &
                            ZH_cp0_nlo_bb(x, collider, ghb, strict)

    end function ZH_cp0_nlo_ggqqbb

    function ZH_cp0_nnlo(x, collider, ghz, ght, ghb, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cp0_nnlo

        ZH_cp0_nnlo = ghz**2.0D0*ZHcoeff_func(x, collider, 99, strict) + &
                      ght**2.0D0*ZHcoeff_func(x, collider, 95, strict) + &
                      ght*ghz*ZHcoeff_func(x, collider, 101, strict) + &
                      ght*ghb*ZHcoeff_func(x, collider, 105, strict) + &
                      ghb**2.0D0*ZHcoeff_func(x, collider, 97, strict) + &
                      ghb*ghz*ZHcoeff_func(x, collider, 103, strict)
        ZH_cp0_nnlo = ZH_cp0_nnlo/1000.0D0 ! convert from fb to pb
    end function ZH_cp0_nnlo

    function ZH_cp0_nnlo_gg(x, collider, ghz, ght, ghb, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cp0_nnlo_gg

        ZH_cp0_nnlo_gg = ghz**2.0D0*ZHcoeff_func(x, collider, 111, strict) + &
                         ght**2.0D0*ZHcoeff_func(x, collider, 107, strict) + &
                         ght*ghz*ZHcoeff_func(x, collider, 113, strict) + &
                         ght*ghb*ZHcoeff_func(x, collider, 117, strict) + &
                         ghb**2.0D0*ZHcoeff_func(x, collider, 109, strict) + &
                         ghb*ghz*ZHcoeff_func(x, collider, 115, strict)
        ZH_cp0_nnlo_gg = ZH_cp0_nnlo_gg/1000.0D0 ! convert from fb to pb
    end function ZH_cp0_nnlo_gg

    function ZH_cp0_nnlo_qq(x, collider, ghz, ght, ghb, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cp0_nnlo_qq

        ZH_cp0_nnlo_qq = ghz**2.0D0*ZHcoeff_func(x, collider, 123, strict) + &
                         ght**2.0D0*ZHcoeff_func(x, collider, 119, strict) + &
                         ght*ghz*ZHcoeff_func(x, collider, 125, strict) + &
                         ght*ghb*ZHcoeff_func(x, collider, 129, strict) + &
                         ghb**2.0D0*ZHcoeff_func(x, collider, 121, strict) + &
                         ghb*ghz*ZHcoeff_func(x, collider, 127, strict)
        ZH_cp0_nnlo_qq = ZH_cp0_nnlo_qq/1000.0D0 ! convert from fb to pb
    end function ZH_cp0_nnlo_qq

    function ZH_cp0_nnlo_bb(x, collider, ghb, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghb
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cp0_nnlo_bb

        ZH_cp0_nnlo_bb = ghb**2.0D0*ZHcoeff_func(x, collider, 131, strict)
        ZH_cp0_nnlo_bb = ZH_cp0_nnlo_bb/1000.0D0 ! convert from fb to pb
    end function ZH_cp0_nnlo_bb

    function ZH_cp0_nnlo_ggqqbb(x, collider, ghz, ght, ghb, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cp0_nnlo_ggqqbb

        ZH_cp0_nnlo_ggqqbb = ZH_cp0_nnlo_gg(x, collider, ghz, ght, ghb, strict) + &
                             ZH_cp0_nnlo_qq(x, collider, ghz, ght, ghb, strict) + &
                             ZH_cp0_nnlo_bb(x, collider, ghb, strict)

    end function ZH_cp0_nnlo_ggqqbb

    function ZH_cpmix_nlo(x, collider, ghz, ght, ghb, gat, gab, strict)
        ! (TS 16/01/2020: Commented out CP-even/CP-odd interference terms. These are
        !                 absent under the assumption that g(hhZ) = 0.
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb, gat, gab
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cpmix_nlo

        ZH_cpmix_nlo = ghz**2.0D0*ZHcoeff_func(x, collider, 7, strict) + &
                       ghz*ght*ZHcoeff_func(x, collider, 9, strict) + &
                       ghz*ghb*ZHcoeff_func(x, collider, 11, strict) + &
                       gat**2.0D0*ZHcoeff_func(x, collider, 13, strict) + &
                       ! gat*ghz*ZHcoeff_func(x, collider, 19, strict) + &
                       ! gat*ght*ZHcoeff_func(x, collider, 15, strict) + &
                       ! gat*ghb*ZHcoeff_func(x, collider, 17, strict) + &
                       ght**2.0D0*ZHcoeff_func(x, collider, 1, strict) + &
                       ght*ghb*ZHcoeff_func(x, collider, 5, strict) + &
                       gab**2.0D0*ZHcoeff_func(x, collider, 21, strict) + &
                       ! gab*ghz*ZHcoeff_func(x, collider, 27, strict) + &
                       gab*gat*ZHcoeff_func(x, collider, 29, strict) + &
                       ! gab*ght*ZHcoeff_func(x, collider, 23, strict) + &
                       ! gab*ghb*ZHcoeff_func(x, collider, 25, strict) + &
                       ghb**2.0D0*ZHcoeff_func(x, collider, 3, strict)
        ZH_cpmix_nlo = ZH_cpmix_nlo/1000.0D0 ! convert from fb to pb
    end function ZH_cpmix_nlo

    function ZH_cpmix_nlo_gg(x, collider, ghz, ght, ghb, gat, gab, strict)
        ! (TS 16/01/2020: Commented out CP-even/CP-odd interference terms. These are
        !                 absent under the assumption that g(hhZ) = 0.
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb, gat, gab
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cpmix_nlo_gg

        ZH_cpmix_nlo_gg = ghz**2.0D0*ZHcoeff_func(x, collider, 37, strict) + &
                          ghz*ght*ZHcoeff_func(x, collider, 39, strict) + &
                          ghz*ghb*ZHcoeff_func(x, collider, 41, strict) + &
                          gat**2.0D0*ZHcoeff_func(x, collider, 43, strict) + &
                          !                          gat*ghz*ZHcoeff_func(x, collider, 49, strict) + &
                          !                          gat*ght*ZHcoeff_func(x, collider, 45, strict) + &
                          !                          gat*ghb*ZHcoeff_func(x, collider, 47, strict) + &
                          ght**2.0D0*ZHcoeff_func(x, collider, 31, strict) + &
                          ght*ghb*ZHcoeff_func(x, collider, 35, strict) + &
                          gab**2.0D0*ZHcoeff_func(x, collider, 51, strict) + &
                          !                          gab*ghz*ZHcoeff_func(x, collider, 57, strict) + &
                          gab*gat*ZHcoeff_func(x, collider, 59, strict) + &
                          !                          gab*ght*ZHcoeff_func(x, collider, 53, strict) + &
                          !                          gab*ghb*ZHcoeff_func(x, collider, 55, strict) + &
                          ghb**2.0D0*ZHcoeff_func(x, collider, 33, strict)
        ZH_cpmix_nlo_gg = ZH_cpmix_nlo_gg/1000.0D0 ! convert from fb to pb
    end function ZH_cpmix_nlo_gg

    function ZH_cpmix_nlo_qq(x, collider, ghz, ght, ghb, gat, gab, strict)
        ! (TS 16/01/2020: Commented out CP-even/CP-odd interference terms. These are
        !                 absent under the assumption that g(hhZ) = 0.
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb, gat, gab
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cpmix_nlo_qq

        ZH_cpmix_nlo_qq = ghz**2.0D0*ZHcoeff_func(x, collider, 67, strict) + &
                          ghz*ght*ZHcoeff_func(x, collider, 69, strict) + &
                          ghz*ghb*ZHcoeff_func(x, collider, 71, strict) + &
                          gat**2.0D0*ZHcoeff_func(x, collider, 73, strict) + &
                          !                          gat*ghz*ZHcoeff_func(x, collider, 79, strict) + &
                          !                          gat*ght*ZHcoeff_func(x, collider, 75, strict) + &
                          !                          gat*ghb*ZHcoeff_func(x, collider, 77, strict) + &
                          ght**2.0D0*ZHcoeff_func(x, collider, 61, strict) + &
                          ght*ghb*ZHcoeff_func(x, collider, 65, strict) + &
                          gab**2.0D0*ZHcoeff_func(x, collider, 81, strict) + &
                          !                          gab*ghz*ZHcoeff_func(x, collider, 87, strict) + &
                          gab*gat*ZHcoeff_func(x, collider, 89, strict) + &
                          !                          gab*ght*ZHcoeff_func(x, collider, 83, strict) + &
                          !                          gab*ghb*ZHcoeff_func(x, collider, 85, strict) + &
                          ghb**2.0D0*ZHcoeff_func(x, collider, 63, strict)
        ZH_cpmix_nlo_qq = ZH_cpmix_nlo_qq/1000.0D0 ! convert from fb to pb
    end function ZH_cpmix_nlo_qq

    function ZH_cpmix_nlo_bb(x, collider, ghb, gab, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghb, gab
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cpmix_nlo_bb

        ZH_cpmix_nlo_bb = (ghb**2.0D0 + gab**2.0D0)*ZHcoeff_func(x, collider, 91, strict)
        ZH_cpmix_nlo_bb = ZH_cpmix_nlo_bb/1000.0D0 ! convert from fb to pb
    end function ZH_cpmix_nlo_bb

    function ZH_cpmix_nlo_ggqqbb(x, collider, ghz, ght, ghb, gat, gab, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb, gat, gab
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cpmix_nlo_ggqqbb

        ZH_cpmix_nlo_ggqqbb = ZH_cpmix_nlo_gg(x, collider, ghz, ght, ghb, gat, gab, strict) + &
                              ZH_cpmix_nlo_qq(x, collider, ghz, ght, ghb, gat, gab, strict) + &
                              ZH_cpmix_nlo_bb(x, collider, ghb, gab, strict)

    end function ZH_cpmix_nlo_ggqqbb

    function ZH_cpmix_nnlo_qq(x, collider, ghz, ght, ghb, gat, gab, strict)
        use usefulbits, only: vsmall
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb, gat, gab
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cpmix_nnlo_qq

        if ((abs(ghz) .lt. vsmall) .and. (abs(ght) .lt. vsmall) .and. (abs(ghb) .lt. vsmall)) then
            ZH_cpmix_nnlo_qq = ZH_cpmix_nlo_qq(x, collider, ghz, ght, ghb, gat, gab, strict)* &
                               div(ZH_cp0_nnlo_qq(x, collider, 1.0D0, 1.0D0, 1.0D0, strict), &
                                   ZH_cp0_nlo_qq(x, collider, 1.0D0, 1.0D0, 1.0D0, strict), 1.0D0, 0.0D0)

        else
            ZH_cpmix_nnlo_qq = ZH_cpmix_nlo_qq(x, collider, ghz, ght, ghb, gat, gab, strict)* &
                               div(ZH_cp0_nnlo_qq(x, collider, ghz, ght, ghb, strict), &
                                   ZH_cp0_nlo_qq(x, collider, ghz, ght, ghb, strict), 1.0D0, 0.0D0)

        end if

    end function ZH_cpmix_nnlo_qq

    function ZH_cpmix_nnlo_bb(x, collider, ghb, gab, strict)
        use usefulbits, only: vsmall
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghb, gab
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cpmix_nnlo_bb

        if (abs(ghb) .lt. vsmall) then
            ZH_cpmix_nnlo_bb = ZH_cpmix_nlo_bb(x, collider, ghb, gab, strict)* &
                               div(ZH_cp0_nnlo_bb(x, collider, 1.0D0, strict), &
                                   ZH_cp0_nlo_bb(x, collider, 1.0D0, strict), 1.0D0, 0.0D0)

        else
            ZH_cpmix_nnlo_bb = ZH_cpmix_nlo_bb(x, collider, ghb, gab, strict)* &
                               div(ZH_cp0_nnlo_bb(x, collider, ghb, strict), &
                                   ZH_cp0_nlo_bb(x, collider, ghb, strict), 1.0D0, 0.0D0)

        end if

    end function ZH_cpmix_nnlo_bb

    function ZH_cpmix_nnlo_gg(x, collider, ghz, ght, ghb, gat, gab, strict)
        use usefulbits, only: vsmall
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb, gat, gab
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cpmix_nnlo_gg

        if ((abs(ghz) .lt. vsmall) .and. (abs(ght) .lt. vsmall) .and. (abs(ghb) .lt. vsmall)) then
            ZH_cpmix_nnlo_gg = ZH_cpmix_nlo_gg(x, collider, ghz, ght, ghb, gat, gab, strict)* &
                               div(ZH_cp0_nnlo_gg(x, collider, 1.0D0, 1.0D0, 1.0D0, strict), &
                                   ZH_cp0_nlo_gg(x, collider, 1.0D0, 1.0D0, 1.0D0, strict), 1.0D0, 0.0D0)

        else
            ZH_cpmix_nnlo_gg = ZH_cpmix_nlo_gg(x, collider, ghz, ght, ghb, gat, gab, strict)* &
                               div(ZH_cp0_nnlo_gg(x, collider, ghz, ght, ghb, strict), &
                                   ZH_cp0_nlo_gg(x, collider, ghz, ght, ghb, strict), 1.0D0, 0.0D0)

        end if

    end function ZH_cpmix_nnlo_gg

    function ZH_cpmix_nnlo(x, collider, ghz, ght, ghb, gat, gab, strict)
        use usefulbits, only: vsmall
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb, gat, gab
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cpmix_nnlo

        if ((abs(ghz) .lt. vsmall) .and. (abs(ght) .lt. vsmall) .and. (abs(ghb) .lt. vsmall)) then
            ZH_cpmix_nnlo = ZH_cpmix_nlo(x, collider, ghz, ght, ghb, gat, gab, strict)* &
                            div(ZH_cp0_nnlo(x, collider, 1.0D0, 1.0D0, 1.0D0, strict), &
                                ZH_cp0_nlo(x, collider, 1.0D0, 1.0D0, 1.0D0, strict), 1.0D0, 0.0D0)

        else
            ZH_cpmix_nnlo = ZH_cpmix_nlo(x, collider, ghz, ght, ghb, gat, gab, strict)* &
                            div(ZH_cp0_nnlo(x, collider, ghz, ght, ghb, strict), &
                                ZH_cp0_nlo(x, collider, ghz, ght, ghb, strict), 1.0D0, 0.0D0)

        end if

    end function ZH_cpmix_nnlo

    function ZH_cpmix_nnlo_ggqqbb(x, collider, ghz, ght, ghb, gat, gab, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb, gat, gab
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cpmix_nnlo_ggqqbb

        ZH_cpmix_nnlo_ggqqbb = ZH_cpmix_nnlo_qq(x, collider, ghz, ght, ghb, gat, gab, strict) + &
                               ZH_cpmix_nnlo_bb(x, collider, ghb, gab, strict) + &
                               ZH_cpmix_nnlo_gg(x, collider, ghz, ght, ghb, gat, gab, strict)

    end function ZH_cpmix_nnlo_ggqqbb

    function ZH_cpmix_nnlo_qqbb(x, collider, ghz, ght, ghb, gat, gab, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb, gat, gab
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: ZH_cpmix_nnlo_qqbb

        ZH_cpmix_nnlo_qqbb = ZH_cpmix_nnlo_qq(x, collider, ghz, ght, ghb, gat, gab, strict) + &
                             ZH_cpmix_nnlo_bb(x, collider, ghb, gab, strict)

    end function ZH_cpmix_nnlo_qqbb

    subroutine check_kfactor_ZH(x, collider, ghz, ght, ghb, gat, gab, strict)
        implicit none
        double precision, intent(in) :: x
        double precision, intent(in) :: ghz, ght, ghb, gat, gab
        character(LEN=5), intent(in) :: collider
        logical, optional :: strict
        double precision :: NLOsum, NLOincl

        NLOsum = ZH_cpmix_nlo_ggqqbb(x, collider, ghz, ght, ghb, gat, gab, strict)
        NLOincl = ZH_cpmix_nlo(x, collider, ghz, ght, ghb, gat, gab, strict)

        !   write(*,*) NLOsum, NLOincl
        if ((abs(NLOsum - NLOincl)/NLOincl) .gt. 1E-04) then
            !-- usually values of 1E-08 or less!
            write (*, *) "WARNING for ZH XS approximation: NNLO/NLO k-factor may not be accurate: ", &
                abs(NLOsum - NLOincl)/NLOincl
        end if

    end subroutine check_kfactor_ZH
!***********************<<<<END ZH FUNCTION BLOCK >>>>>****************
! top quark associated production modes:

    function ttH_polyfit(ght, gat)
! Evaluated with MG5 at LO for a Higgs boson at 125 GeV at 13 TeV LHC.
! Strictly speaking, this fit function does *not* accurately describe
!other cms energies or Higgs boson masses!
        implicit none

        double precision, intent(in) :: ght, gat
        double precision :: ttH_polyfit

        ttH_polyfit = 371.56975827D0*ght**2.0D0 - 0.53414905D0*ght*gat + 155.82194562*gat**2.0D0

    end function ttH_polyfit

    function ttH_modifier(ght, gat)
        implicit none

        double precision, intent(in) :: ght, gat
        double precision :: ttH_modifier

        ttH_modifier = ttH_polyfit(ght, gat)/ttH_polyfit(1.0D0, 0.0D0)

    end function ttH_modifier

    function tH_tchan_polyfit(ght, gat, ghw)
! Evaluated with MG5 at LO for a Higgs boson at 125 GeV at 13 TeV LHC.
! Strictly speaking, this fit function does *not* accurately describe
!other cms energies or Higgs boson masses!
        implicit none

        double precision, intent(in) :: ght, gat, ghw
        double precision :: tH_tchan_polyfit

        tH_tchan_polyfit = -3.73162086D02*ghw*ght + 2.05680800D-01*ghw*gat - 9.72507924D-02*ght*gat &
                           + 2.00596784D02*ght**2.0D0 + 6.09045448D01*gat**2.0D0 + 2.33755065D+02*ghw**2.0D0

    end function tH_tchan_polyfit

    function tH_tchan_modifier(ght, gat, ghw)
        implicit none

        double precision, intent(in) :: ght, gat, ghw
        double precision :: tH_tchan_modifier

        tH_tchan_modifier = tH_tchan_polyfit(ght, gat, ghw)/tH_tchan_polyfit(1.0D0, 0.0D0, 1.0D0)

    end function tH_tchan_modifier

    !> SM Higgs reference cross section for the gb->tWH process
    !! Taken from LHC HXSWG (https://twiki.cern.ch/twiki/bin/view/LHCPhysics/CERNYellowReportPageAt13TeV),
    !! implemented only for MH = 125.0 GeV. (no other predictions available yet)
    !! Using prediction at NLO QCD (no NLO EW) in 5FS, using DR2.
    !! NEED  TO STILL CHECK THAT THE XS IS THE SUM OVER THE POSSIBLE CHARGES!
    !! @mass Higgs boson mass (only values of 125.0 \pm 1 GeV give non-zero results)
    function XS_lhc13_gb_tWH_SM(mass)
        implicit none
        double precision, intent(in) :: mass
        double precision :: XS_lhc13_gb_tWH_SM
        if (abs(mass - 125.0D0) .le. 1.0D0) then
            XS_lhc13_gb_tWH_SM = 0.01517D0
        else
            XS_lhc13_gb_tWH_SM = 0.0D0
        end if

    end function XS_lhc13_gb_tWH_SM
    !> SM Higgs reference cross section for the gb->tWH process
    !! Taken from LHC HXSWG (https://twiki.cern.ch/twiki/bin/view/LHCPhysics/CERNYellowReportPageAt7TeV),
    !! implemented only for MH = 125.0 GeV. (no other predictions available yet)
    !! Using prediction at NLO QCD (no NLO EW) in 5FS, using DR2.
    !! NEED  TO STILL CHECK THAT THE XS IS THE SUM OVER THE POSSIBLE CHARGES!
    !! @mass Higgs boson mass (only values of 125.0 \pm 1 GeV give non-zero results)
    function XS_lhc7_gb_tWH_SM(mass)
        implicit none
        double precision, intent(in) :: mass
        double precision :: XS_lhc7_gb_tWH_SM
        if (abs(mass - 125.0D0) .le. 1.0D0) then
            XS_lhc7_gb_tWH_SM = 0.00223D0
        else
            XS_lhc7_gb_tWH_SM = 0.0D0
        end if
    end function XS_lhc7_gb_tWH_SM
    !> SM Higgs reference cross section for the gb->tWH process
    !! Taken from LHC HXSWG (https://twiki.cern.ch/twiki/bin/view/LHCPhysics/CERNYellowReportPageAt8TeV),
    !! implemented only for MH = 125.0 GeV. (no other predictions available yet)
    !! Using prediction at NLO QCD (no NLO EW) in 5FS, using DR2.
    !! NEED  TO STILL CHECK THAT THE XS IS THE SUM OVER THE POSSIBLE CHARGES!
    !! @mass Higgs boson mass (only values of 125.0 \pm 1 GeV give non-zero results)
    function XS_lhc8_gb_tWH_SM(mass)
        implicit none
        double precision, intent(in) :: mass
        double precision :: XS_lhc8_gb_tWH_SM
        if (abs(mass - 125.0D0) .le. 1.0D0) then
            XS_lhc8_gb_tWH_SM = 0.00351D0
        else
            XS_lhc8_gb_tWH_SM = 0.0D0
        end if
    end function XS_lhc8_gb_tWH_SM
    !> Polynomial fit function of the CP-dependence of tWH production
    !! Evaluated with MG5 at LO at a Higgs boson mass of 125 GeV at 13 TeV.
    !! @ ght CP-even Higgs-top-top coupling (normalized to SM)
    !! @ gat CP-odd Higgs-top-top coupling (normalized to SM)
    !! @ ghw Higgs-W-W coupling (normalized to SM)
    function tWH_polyfit(ght, gat, ghw)
        implicit none

        double precision, intent(in) :: ght, gat, ghw
        double precision :: tWH_polyfit

        tWH_polyfit = -62.0D0*ghw*ght + 45.0D0*ght**2.0D0 + 34.0D0*gat**2.0D0 + 33.0D0*ghw**2.0D0

    end function tWH_polyfit

    !> Signal strength modifier for tWH production at 13 TeV, Higgs mass = 125 GeV.
    !! @ ght CP-even Higgs-top-top coupling (normalized to SM)
    !! @ gat CP-odd Higgs-top-top coupling (normalized to SM)
    !! @ ghw Higgs-W-W coupling (normalized to SM)
    function tWH_modifier(ght, gat, ghw)
        implicit none

        double precision, intent(in) :: ght, gat, ghw
        double precision :: tWH_modifier

        tWH_modifier = tWH_polyfit(ght, gat, ghw)/tWH_polyfit(1.0D0, 0.0D0, 1.0D0)

    end function tWH_modifier
    !***********************<<<<END ttH FUNCTION BLOCK >>>>>****************

    ! Charged Higgs cross section
    function tHc_cxn(MHc, gHcjt, gHcjb, BR_tHpjb, strict)
        use usefulbits, only: vsmall
        implicit none
        double precision, intent(in) :: mHc, gHcjt, gHcjb, BR_tHpjb
        logical, optional, intent(in) :: strict
        double precision :: tHc_cxn
        double precision :: x_tt, x_tb, x_bb

        if (strict) continue ! silence unused variable warning
        call testXSSM(mHc)

        if (mHc .lt. tHccoeff(1)%xmin .or. mHc .gt. tHccoeff(1)%xmax) then
            tHc_cxn = 0.D0
            RETURN
        end if

        call interpolate_tabletype1(mHc, tHccoeff(1), 1, x_tt, .True.)
        call interpolate_tabletype1(mHc, tHccoeff(1), 2, x_tb, .True.)
        call interpolate_tabletype1(mHc, tHccoeff(1), 3, x_bb, .True.)

        ! factor 2 for Hp + Hm
        tHc_cxn = 2*(x_tt*gHcjt**2 + x_tb*gHcjt*gHcjb + x_bb*gHcjb**2)
        if (BR_tHpjb .gt. vsmall) then
            tHc_cxn = tHc_cxn*(1 - BR_tHpjb)**2
        end if
    end function tHc_cxn
!> Cross section at the LHC 13 Tev for neutral scalar + photon production from partonic initial states
!! @ Mh Neutral scalar (phi) mass (in GeV)
!! @ coupling coupling strength (SM-normalized in case there is a non-zero SM Higgs equivalent)
!! @ whichcoupling Dertermines the scalar-fermion-fermion coupling
!!  |   whichcoupling   |   description         |
!!  |-------------------|-----------------------|
!!  |      1            |   u-u-phi (SM norm.)  |
!!  |      2            |   d-d-phi (SM norm.)  |
!!  |      3            |   c-c-phi (SM norm.)  |
!!  |      4            |   s-s-phi (SM norm.)  |
!!  |      5            |   b-b-phi (SM norm.)  |
!!  |      6            |   u-c-phi             |
!!  |      7            |   d-s-phi             |
!!  |      8            |   d-b-phi             |
!!  |      9            |   s-b-phi             |
    function neutral_scalar_plus_photon_lhc13(Mh, coupling, whichcoupling, strict)
        use usefulbits
        implicit none
        double precision, intent(in) :: Mh, coupling
        integer, intent(in) :: whichcoupling
        logical, optional, intent(in) :: strict
        double precision :: neutral_scalar_plus_photon_lhc13
        double precision :: g, xs

        select case (whichcoupling)
        case (1) ! uu -> phi + photon
            g = coupling*(mu/vev) ! Convert SM-normalized coupling to absolute value
            xs = 3.69548D0 - 7.40884D07/(Mh**3.0D0) + 4.49543D06/(Mh**2.0D0) - &
                 6390.61D0/Mh - 0.000795657*Mh
        case (2) ! dd -> phi + photon
            g = coupling*(md/vev) ! Convert SM-normalized coupling to absolute value
            xs = 1.6094D0 - 2.60547D07/(Mh**3.0D0) + 977832.D0/(Mh**2.0D0) - &
                 1895.61D0/Mh - 0.000534126D0*Mh
        case (3) ! cc -> phi + photon
            g = coupling*(mc/vev) ! Convert SM-normalized coupling to absolute value
            xs = 0.71179D0 + 3.63856D7/(Mh**3.0D0) + 207310.D0/(Mh**2.0D0) - &
                 680.539D0/Mh - 0.000256867D0*Mh
        case (4) ! ss -> phi + photon
            g = coupling*(ms/vev) ! Convert SM-normalized coupling to absolute value
            xs = 0.172986D0 + 1.57635D07/(Mh**3.0D0) + 61422.7D0/(Mh**2.0D0) - &
                 184.656D0/Mh - 0.0000559835D0*Mh
        case (5) ! bb -> phi + photon
            g = coupling*(mbmb/vev) ! Convert SM-normalized coupling to absolute value
            xs = 0.406157D0 + 567982.0D0/(Mh**3.0D0) + 201805.0D0/(Mh**2.0D0) - &
                 448.806D0/Mh - 0.000136612D0*Mh
        case (6) ! uc -> phi + photon
            g = coupling ! FV coupling is already absolute
            xs = 4.49248D0 + 5.65276D07/(Mh**3.0D0) + 3.48162D06/(Mh**2.0D0) - &
                 6279.74D0/Mh - 0.00119019*Mh
        case (7) ! ds -> phi + photon
            g = coupling ! FV coupling is already absolute
            xs = 1.28013D0 + 1.68853D07/(Mh**3.0D0) + 699651.D0/(Mh**2.0D0) - &
                 1510.12D0/Mh - 0.00040275D0*Mh
        case (8) ! db -> phi + photon
            g = coupling ! FV coupling is already absolute
            xs = 0.607085D0 + 8.13777D6/(Mh**3.0D0) + 330773.0D0/(Mh**2.0D0) - &
                 711.803D0/Mh - 0.000192274D0*Mh
        case (9) ! sb -> phi + photon
            g = coupling ! FV coupling is already absolute
            xs = 0.613265D0 - 3.90384D6/(Mh**3.0D0) + 279829.0D0/(Mh**2.0D0) - &
                 646.173D0/Mh - 0.000215673D0*Mh
        end select

        neutral_scalar_plus_photon_lhc13 = g**2.0D0*xs

        if (present(strict)) then
            if (strict) then
                if ((Mh > 1100.0D0) .or. (Mh < 200.0D0)) then
                    neutral_scalar_plus_photon_lhc13 = 0.0d0
                end if
            end if
        end if

    end function neutral_scalar_plus_photon_lhc13

    !> Cross section at the LHC 13 Tev for negative charged scalar + photon production from partonic initial states
    !! @ Mh Charged scalar (phi) mass (in GeV)
    !! @ couplingL left-handed coupling (g_L from eq 2 in the beyond Higgs paper)
    !! @ couplingR right-handed coupling (g_R from eq 2 in the beyond Higgs paper)
    !! @ whichcoupling Selects the scalar-fermion-fermion coupling
    !!  |   whichcoupling   |   description         |
    !!  |-------------------|-----------------------|
    !!  |      1            |   u-d-phi             |
    !!  |      2            |   c-s-phi             |
    !!  |      3            |   u-s-phi             |
    !!  |      4            |   c-d-phi             |
    !!  |      5            |   u-b-phi             |
    !!  |      6            |   c-b-phi             |
    function negative_charged_scalar_plus_photon_lhc13(Mh, couplingL, couplingR, whichcoupling, strict)
        use usefulbits
        implicit none
        double precision, intent(in) :: Mh, couplingL, couplingR
        integer, intent(in) :: whichcoupling
        logical, optional, intent(in) :: strict
        double precision :: negative_charged_scalar_plus_photon_lhc13
        double precision :: gsq, xs

        select case (whichcoupling)
        case (1) ! ud -> phi + photon
            xs = 0.98188D0 - 1.73381D07/(Mh**3.0D0) + 652027.0D0/(Mh**2.0D0) - &
                 1223.17D0/Mh - 0.000307538D0*Mh
        case (2) ! cs -> phi + photon
            xs = 0.125393D0 + 5.3322D06/(Mh**3.0D0) + 52331.9D0/(Mh**2.0D0) - &
                 136.529D0/Mh - 0.0000409939*Mh
        case (3) ! us -> phi + photon
            xs = 0.335395D0 + 3.71034D06/(Mh**3.0D0) + 142254.0D0/(Mh**2.0D0) - &
                 351.939D0/Mh - 0.000116551D0*Mh
        case (4) ! cd -> phi + photon
            xs = 0.917357D0 - 1.5052D07/(Mh**3.0D0) + 457490.0D0/(Mh**2.0D0) - &
                 1006.88D0/Mh - 0.000313157*Mh
        case (5) ! ub -> phi + photon
            xs = 0.182345D0 + 2.70981D06/(Mh**3.0D0) + 72679.9D0/(Mh**2.0D0) - &
                 190.285D0/Mh - 0.0000624154D0*Mh
        case (6) ! cb -> phi + photon
            xs = 0.0822505D0 + 2.84796D06/(Mh**3.0D0) + 28145.8D0/(Mh**2.0D0) - &
                 82.7795D0/Mh - 0.0000285173D0*Mh
        end select

        gsq = couplingL**2 + couplingR**2
        negative_charged_scalar_plus_photon_lhc13 = gsq*xs

        if (present(strict)) then
            if (strict) then
                if ((Mh > 1100.0D0) .or. (Mh < 200.0D0)) then
                    negative_charged_scalar_plus_photon_lhc13 = 0.0d0
                end if
            end if
        end if

    end function negative_charged_scalar_plus_photon_lhc13

    !> Cross section at the LHC 13 Tev for positive charged scalar + photon production from partonic initial states
    !! @ Mh Charged scalar (phi) mass (in GeV)
    !! @ couplingL left-handed coupling (g_L from eq 2 in the beyond Higgs paper)
    !! @ couplingR right-handed coupling (g_R from eq 2 in the beyond Higgs paper)
    !! @ whichcoupling Selects the scalar-fermion-fermion coupling
    !!  |   whichcoupling   |   description         |
    !!  |-------------------|-----------------------|
    !!  |      1            |   u-d-phi             |
    !!  |      2            |   c-s-phi             |
    !!  |      3            |   u-s-phi             |
    !!  |      4            |   c-d-phi             |
    !!  |      5            |   u-b-phi             |
    !!  |      6            |   c-b-phi             |
    function positive_charged_scalar_plus_photon_lhc13(Mh, couplingL, couplingR, whichcoupling, strict)
        use usefulbits
        implicit none
        double precision, intent(in) :: Mh, couplingL, couplingR
        integer, intent(in) :: whichcoupling
        logical, optional, intent(in) :: strict
        double precision :: positive_charged_scalar_plus_photon_lhc13
        double precision :: gsq, xs

        select case (whichcoupling)
        case (1) ! ud -> phi + photon
            xs = -0.216092D0 - 471225D0/Mh**3 + 445930D0/Mh**2 - 247.076D0/Mh + 0.000173311D0*Mh
        case (2) ! cs -> phi + photon
            xs = 0.102024D0 + 6.77824D6/Mh**3 + 34604.7D0/Mh**2 - 104.975D0/Mh - 0.0000347606D0*Mh
        case (3) ! us -> phi + photon
            xs = 0.0805123D0 + 2.83736D6/Mh**3 + 296278D0/Mh**2 - 329.227D0/Mh + 0.0000216609D0*Mh
        case (4) ! cd -> phi + photon
            xs = 0.39282D0 + 2.87478D6/Mh**3 + 148855D0/Mh**2 - 395.107D0/Mh - 0.000140121D0*Mh
        case (5) ! ub -> phi + photon
            xs = 0.775128D0 - 2.48801D7/Mh**3 + 396466D0/Mh**2 - 815.75D0/Mh - 0.000288148D0*Mh
        case (6) ! cb -> phi + photon
            xs = 0.0525333D0 + 3.8965D6/Mh**3 + 19429.3D0/Mh**2 - 57.5982D0/Mh - 0.000016354D0*Mh
        end select

        gsq = couplingL**2 + couplingR**2
        positive_charged_scalar_plus_photon_lhc13 = gsq*xs

        if (present(strict)) then
            if (strict) then
                if ((Mh > 1100.0D0) .or. (Mh < 200.0D0)) then
                    positive_charged_scalar_plus_photon_lhc13 = 0.0d0
                end if
            end if
        end if

    end function positive_charged_scalar_plus_photon_lhc13

    !> Cross section at the LHC 13 Tev for neutral scalar production from quark initial states
        !! @ Mh Neutral scalar (phi) mass (in GeV)
        !! @ coupling coupling strength (SM-normalized in case there is a non-zero SM Higgs equivalent)
        !! @ whichcoupling Dertermines the scalar-fermion-fermion coupling
        !!  |   whichcoupling   |   description         |
        !!  |-------------------|-----------------------|
        !!  |      1            |   u-u-phi (SM norm.)  |
        !!  |      2            |   d-d-phi (SM norm.)  |
        !!  |      3            |   c-c-phi (SM norm.)  |
        !!  |      4            |   s-s-phi (SM norm.)  |
        !!  |      5            |   b-b-phi (SM norm.)  |
        !!  |      6            |   u-c-phi             |
        !!  |      7            |   d-s-phi             |
        !!  |      8            |   d-b-phi             |
        !!  |      9            |   s-b-phi             |
    function neutral_scalar_from_quarks_lhc13(Mh, coupling, whichcoupling, strict)
        use usefulbits
        implicit none
        double precision, intent(in) :: Mh, coupling
        integer, intent(in) :: whichcoupling
        logical, optional, intent(in) :: strict
        double precision :: neutral_scalar_from_quarks_lhc13
        double precision :: g, xs

        select case (whichcoupling)
        case (1) ! uu -> phi
            g = coupling*(mu/vev) ! Convert SM-normalized coupling to absolute value
            xs = 254.458D0 + 9.01509D10/(Mh**3.0D0) + 4.18827D07/(Mh**2.0D0) - &
                 245875.D0/Mh - 0.0908537*Mh
        case (2) ! dd -> phi
            g = coupling*(md/vev) ! Convert SM-normalized coupling to absolute value
            xs = 58.2871D0 + 7.07833D10/(Mh**3.0D0) - 3.84276D7/(Mh**2.0D0) - &
                 42109.9D0/Mh - 0.0205486*Mh
        case (3) ! cc -> phi
            g = coupling*(mc/vev) ! Convert SM-normalized coupling to absolute value
            xs = -40.8521D0 + 1.50538D10/(Mh**3.0D0) - 4.38353D7/(Mh**2.0D0) + &
                 59437.3D0/Mh + 0.0113045D0*Mh
        case (4) ! ss -> phi
            g = coupling*(ms/vev) ! Convert SM-normalized coupling to absolute value
            xs = -67.2994D0 + 2.34862D10/(Mh**3.0D0) - 6.6938D07/(Mh**2.0) + &
                 93341.3D0/Mh + 0.0196796D0*Mh
        case (5) ! bb -> phi   ! Not really needed, will use SM Higgs prediction.
            g = coupling*(mbmb/vev) ! Convert SM-normalized coupling to absolute value
            xs = 93.5308D0 + 5.86328D10/(Mh**3.0D0) - 3.84769D7/(Mh**2.0D0) - &
                 53581.8D0/Mh - 0.0402486*Mh
        case (6) ! uc -> phi
            g = coupling ! FV coupling is already absolute
            xs = 87.893D0 + 9.09597D10/(Mh**3.0D0) - 7.52852D7/(MH**2.0D0) - &
                 37365.5D0/Mh - 0.0371667*Mh
        case (7) ! ds -> phi
            g = coupling ! FV coupling is already absolute
            xs = 114.545d0 + 1.72313D11/(Mh**3.0d0) - 1.75715D8/(Mh**2.0d0) - &
                 3836.18D0/Mh - 0.0551281*Mh
        case (8) ! db -> phi
            g = coupling ! FV coupling is already absolute
            xs = 87.2187D0 + 4.19579D10/(Mh**3.0D0) - 1.8564D7/(Mh**2.0D0) - &
                 60170.9D0/Mh - 0.0351971D0*Mh
        case (9) ! sb -> phi
            g = coupling ! FV coupling is already absolute
            xs = 58.3277D0 + 2.65898D10/Mh**3.0D0 - 9.68092D6/(Mh**2.0D0) - &
                 41054.6D0/Mh - 0.0238107*Mh
        end select

        neutral_scalar_from_quarks_lhc13 = g**2.0D0*xs

        if (present(strict)) then
            if (strict) then
                if ((Mh > 1100.0D0) .or. (Mh < 200.0D0)) then
                    neutral_scalar_from_quarks_lhc13 = 0.0d0
                end if
            end if
        end if

    end function neutral_scalar_from_quarks_lhc13

    !> Cross section at the LHC 13 Tev for s-channel positive charged scalar production from partonic initial states
    !! @ Mh Charged scalar (phi) mass (in GeV)
    !! @ couplingL left-handed coupling (g_L from eq 2 in the beyond Higgs paper)
    !! @ couplingR right-handed coupling (g_R from eq 2 in the beyond Higgs paper)
    !! @ whichcoupling Selects the scalar-fermion-fermion coupling
    !!  |   whichcoupling   |   description         |
    !!  |-------------------|-----------------------|
    !!  |      1            |   u-d-phi             |
    !!  |      2            |   c-s-phi             |
    !!  |      3            |   u-s-phi             |
    !!  |      4            |   c-d-phi             |
    !!  |      5            |   u-b-phi             |
    !!  |      6            |   c-b-phi             |
    function positive_charged_scalar_from_quarks_lhc13(Mh, couplingL, couplingR, whichcoupling, strict)
        use usefulbits
        implicit none
        double precision, intent(in) :: Mh, couplingL, couplingR
        integer, intent(in) :: whichcoupling
        logical, optional, intent(in) :: strict
        double precision :: positive_charged_scalar_from_quarks_lhc13
        double precision :: gsq, xs

        select case (whichcoupling)
        case (1) ! ud -> phi
            xs = 132.009D0 + 4.5284D10/Mh**3 + 2.86996D7/Mh**2 - 132718D0/Mh - 0.0460763D0*Mh
        case (2) ! cs -> phi
            xs = -17.502D0 + 8.91285D9/Mh**3 - 2.50802D7/Mh**2 + 30539.2D0/Mh + 0.00400584D0*Mh
        case (3) ! us -> phi
            xs = 26.8752D0 + 4.09273D10/Mh**3 - 2.50004D7/Mh**2 - 21620.2D0/Mh - 0.00701031D0*Mh
        case (4) ! cd -> phi
            xs = -20.178D0 + 1.43062D10/Mh**3 - 3.39139D7/Mh**2 + 36824D0/Mh + 0.00443296D0*Mh
        case (5) ! ub -> phi
            xs = 77.2716D0 + 2.50754D10/Mh**3 - 2.58492D6/Mh**2 - 60789.7D0/Mh - 0.0302666D0*Mh
        case (6) ! cb -> phi
            xs = -10.7985D0 + 5.22174D9/Mh**3 - 1.48684D7/Mh**2 + 18402.6D0/Mh + 0.00237351D0*Mh
        end select

        gsq = couplingL**2 + couplingR**2
        positive_charged_scalar_from_quarks_lhc13 = gsq*xs

        if (present(strict)) then
            if (strict) then
                if ((Mh > 1100.0D0) .or. (Mh < 200.0D0)) then
                    positive_charged_scalar_from_quarks_lhc13 = 0.0d0
                end if
            end if
        end if

    end function positive_charged_scalar_from_quarks_lhc13

    !> Cross section at the LHC 13 Tev for s-channel negative charged scalar production from partonic initial states
    !! @ Mh Charged scalar (phi) mass (in GeV)
    !! @ couplingL left-handed coupling (g_L from eq 2 in the beyond Higgs paper)
    !! @ couplingR right-handed coupling (g_R from eq 2 in the beyond Higgs paper)
    !! @ whichcoupling Selects the scalar-fermion-fermion coupling
    !!  |   whichcoupling   |   description         |
    !!  |-------------------|-----------------------|
    !!  |      1            |   u-d-phi             |
    !!  |      2            |   c-s-phi             |
    !!  |      3            |   u-s-phi             |
    !!  |      4            |   c-d-phi             |
    !!  |      5            |   u-b-phi             |
    !!  |      6            |   c-b-phi             |
    function negative_charged_scalar_from_quarks_lhc13(Mh, couplingL, couplingR, whichcoupling, strict)
        use usefulbits
        implicit none
        double precision, intent(in) :: Mh, couplingL, couplingR
        integer, intent(in) :: whichcoupling
        logical, optional, intent(in) :: strict
        double precision :: negative_charged_scalar_from_quarks_lhc13
        double precision :: gsq, xs

        select case (whichcoupling)
        case (1) ! ud -> phi
            xs = 44.7557D0 + 3.35549D10/(Mh**3.0D0) - 1.81981D7/(Mh**2.0) - &
                 30947.2D0/Mh - 0.0172376*Mh
        case (2) ! cs -> phi
            xs = -32.2039D0 + 9.77269D9/(Mh**3.0D0) - 2.91403D7/(Mh**2.0D0) + &
                 42584.6D0/Mh + 0.00982901D0*Mh
        case (3) ! us -> phi
            xs = -33.1287d0 + 1.68976D10/(Mh**3.0D0) - 4.22103d7/(Mh**2.0D0) + &
                 51821.8/Mh + 0.00863466*Mh
        case (4) ! cd -> phi
            xs = 27.6082D0 + 2.25477D10/(Mh**3.0D0) - 2.27075D7/(Mh**2.0D0) - &
                 9033.18D0/Mh - 0.0128189*Mh
        case (5) ! ub -> phi
            xs = -19.4331d0 + 9.8114D9/(Mh**3.0D0) - 2.54653D7/(Mh**2.0D0) + &
                 30948.2D0/Mh + 0.00502026*Mh
        case (6) ! cb -> phi
            xs = -18.2229D0 + 5.46674D9/(Mh**3.0D0) - 1.69912D7/(Mh**2.0D0) + &
                 24637.7D0/Mh + 0.00543889*Mh
        end select

        gsq = couplingL**2 + couplingR**2
        negative_charged_scalar_from_quarks_lhc13 = gsq*xs

        if (present(strict)) then
            if (strict) then
                if ((Mh > 1100.0D0) .or. (Mh < 200.0D0)) then
                    negative_charged_scalar_from_quarks_lhc13 = 0.0d0
                end if
            end if
        end if

    end function negative_charged_scalar_from_quarks_lhc13
    !******************************************************
    !***                                                ***
    !***                  LHC 7 TeV                     ***
    !***                                                ***
    !******************************************************
    function XS_lhc7_gg_H_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc7_gg_H_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC7 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(1), 1, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(3), 1, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc7_gg_H_SM = interpol

    end function XS_lhc7_gg_H_SM
    !******************************************************
    function XS_lhc7_bb_H_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc7_bb_H_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC7 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(1), 3, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(3), 6, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc7_bb_H_SM = interpol

    end function XS_lhc7_bb_H_SM
    !******************************************************
    function XS_lhc7_vbf_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc7_vbf_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC7 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(1), 2, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(3), 2, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc7_vbf_SM = interpol

    end function XS_lhc7_vbf_SM
    !******************************************************
    function XS_lhc7_HW_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc7_HW_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        badvalue = 0.0D0
        if (present(strict)) then
            if (strict) then
                badvalue = -1.0D0
            end if
        end if
        rangeok = .False.
        if (x .ge. 10.0D0 .and. x .le. 2000) then
            rangeok = .True.
        end if

!   call check_range('LHC7 ',x,rangeok,badvalue,strict)

        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(2), 1, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(3), 3, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc7_HW_SM = interpol

    end function XS_lhc7_HW_SM
    !******************************************************
    function XS_lhc7_HZ_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc7_HZ_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        badvalue = 0.0D0
        if (present(strict)) then
            if (strict) then
                badvalue = -1.0D0
            end if
        end if
        rangeok = .False.
        if (x .ge. 10.0D0 .and. x .le. 2000) then
            rangeok = .True.
        end if

!   call check_range('LHC7 ',x,rangeok,badvalue,strict)

        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(2), 2, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(3), 4, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc7_HZ_SM = interpol

    end function XS_lhc7_HZ_SM
    !******************************************************
    function XS_lhc7_ttH_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc7_ttH_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC7 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            interpol = XS_lhc7_ttH_SM_func(x, strict)
            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(3), 5, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc7_ttH_SM = interpol

    end function XS_lhc7_ttH_SM
    !******************************************************
    function XS_lhc7_tH_tchan_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc7_tH_tchan_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC7 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            interpol = badvalue
            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(3), 7, interpol)
                end if
            end if
        else
            interpol = badvalue
        end if

        XS_lhc7_tH_tchan_SM = interpol

    end function XS_lhc7_tH_tchan_SM
    !******************************************************
    function XS_lhc7_tH_schan_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc7_tH_schan_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC7 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            interpol = badvalue
            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(3), 8, interpol)
                end if
            end if
        else
            interpol = badvalue
        end if

        XS_lhc7_tH_schan_SM = interpol

    end function XS_lhc7_tH_schan_SM
    !******************************************************
    !***                                                ***
    !***                  LHC 8 TeV                     ***
    !***                                                ***
    !******************************************************
    function XS_lhc8_gg_H_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc8_gg_H_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC8 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(4), 1, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(7), 1, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc8_gg_H_SM = interpol

    end function XS_lhc8_gg_H_SM
    !******************************************************
    function XS_lhc8_bb_H_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc8_bb_H_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC8 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(4), 3, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(7), 6, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc8_bb_H_SM = interpol

    end function XS_lhc8_bb_H_SM
    !******************************************************
    function XS_lhc8_vbf_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc8_vbf_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC8 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(4), 2, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(7), 2, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc8_vbf_SM = interpol

    end function XS_lhc8_vbf_SM
    !******************************************************
    function XS_lhc8_HW_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc8_HW_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        badvalue = 0.0D0
        if (present(strict)) then
            if (strict) then
                badvalue = -1.0D0
            end if
        end if
        rangeok = .False.
        if (x .ge. 10.0D0 .and. x .le. 2000) then
            rangeok = .True.
        end if

!   call check_range('LHC8 ',x,rangeok,badvalue,strict)

        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(5), 1, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(7), 3, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc8_HW_SM = interpol

    end function XS_lhc8_HW_SM
    !******************************************************
    function XS_lhc8_HZ_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc8_HZ_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        badvalue = 0.0D0
        if (present(strict)) then
            if (strict) then
                badvalue = -1.0D0
            end if
        end if
        rangeok = .False.
        if (x .ge. 10.0D0 .and. x .le. 2000) then
            rangeok = .True.
        end if

!   call check_range('LHC8 ',x,rangeok,badvalue,strict)

        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(5), 2, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(7), 4, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc8_HZ_SM = interpol

    end function XS_lhc8_HZ_SM
    !******************************************************
    function XS_lhc8_ttH_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc8_ttH_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC8 ', x, rangeok, badvalue, strict)
        if (rangeok) then
!    call interpolate_tabletype1(x,XSSM(6),1,interpol)
            interpol = XS_lhc8_ttH_SM_func(x, strict)
            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(3), 5, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc8_ttH_SM = interpol

    end function XS_lhc8_ttH_SM
    !******************************************************
    function XS_lhc8_tH_tchan_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc8_tH_tchan_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC8 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            interpol = badvalue
            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(7), 7, interpol)
                end if
            end if
        else
            interpol = badvalue
        end if

        XS_lhc8_tH_tchan_SM = interpol

    end function XS_lhc8_tH_tchan_SM
    !******************************************************
    function XS_lhc8_tH_schan_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc8_tH_schan_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC8 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            interpol = badvalue
            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(7), 8, interpol)
                end if
            end if
        else
            interpol = badvalue
        end if

        XS_lhc8_tH_schan_SM = interpol

    end function XS_lhc8_tH_schan_SM
    !******************************************************
    !***                                                ***
    !***                  LHC 13 TeV                     ***
    !***                                                ***
    !******************************************************
    function XS_lhc13_gg_H_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc13_gg_H_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC13', x, rangeok, badvalue, strict)
        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(8), 1, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(12), 1, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc13_gg_H_SM = interpol

    end function XS_lhc13_gg_H_SM
    !******************************************************
    function XS_lhc13_bb_H_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc13_bb_H_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC13', x, rangeok, badvalue, strict)
        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(8), 3, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(12), 6, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc13_bb_H_SM = interpol

    end function XS_lhc13_bb_H_SM
    !******************************************************
    function XS_lhc13_vbf_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc13_vbf_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC13', x, rangeok, badvalue, strict)
        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(8), 2, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(12), 2, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc13_vbf_SM = interpol

    end function XS_lhc13_vbf_SM
    !******************************************************
    function XS_lhc13_HW_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc13_HW_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        badvalue = 0.0D0
        if (present(strict)) then
            if (strict) then
                badvalue = -1.0D0
            end if
        end if
        rangeok = .False.
        if (x .ge. 10.0D0 .and. x .le. 2000) then
            rangeok = .True.
        end if

!   call check_range('lhc13',x,rangeok,badvalue,strict)

        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(9), 1, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(12), 3, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc13_HW_SM = interpol

    end function XS_lhc13_HW_SM
    !******************************************************
    function XS_lhc13_HZ_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc13_HZ_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        badvalue = 0.0D0
        if (present(strict)) then
            if (strict) then
                badvalue = -1.0D0
            end if
        end if
        rangeok = .False.
        if (x .ge. 10.0D0 .and. x .le. 2000) then
            rangeok = .True.
        end if

!   call check_range('lhc13',x,rangeok,badvalue,strict)

        if (rangeok) then
            call interpolate_tabletype1(x, XSSM(9), 2, interpol)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(12), 4, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc13_HZ_SM = interpol

    end function XS_lhc13_HZ_SM
    !******************************************************
    function XS_lhc13_ttH_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc13_ttH_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC13', x, rangeok, badvalue, strict)
        if (rangeok) then
!    call interpolate_tabletype1(x,XSSM(10),1,interpol)
            interpol = XS_lhc13_ttH_SM_func(x, strict)
            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(12), 5, interpol)
                end if
            end if

        else
            interpol = badvalue
        end if

        XS_lhc13_ttH_SM = interpol

    end function XS_lhc13_ttH_SM
    !******************************************************
    function XS_lhc13_tH_tchan_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc13_tH_tchan_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC13', x, rangeok, badvalue, strict)
        if (rangeok) then
!    call interpolate_tabletype1(x,XSSM(11),1,interpol)
            interpol = XS_lhc13_tH_tchan_SM_func(x, strict)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(12), 7, interpol)
                end if
            end if
        else
            interpol = badvalue
        end if

        XS_lhc13_tH_tchan_SM = interpol

    end function XS_lhc13_tH_tchan_SM
    !******************************************************
    function XS_lhc13_tH_schan_SM(x, strict, EWcorr)
        !******************************************************
        implicit none
        double precision, intent(in) :: x
        double precision :: interpol
        double precision :: XS_lhc13_tH_schan_SM
        logical, optional :: strict
        logical, optional :: EWcorr
        logical :: rangeok
        double precision :: badvalue

        call testXSSM(x)

        call check_range('LHC13', x, rangeok, badvalue, strict)
        if (rangeok) then
!    call interpolate_tabletype1(x,XSSM(11),2,interpol)
            interpol = XS_lhc13_tH_schan_SM_func(x, strict)

            if (present(EWcorr)) then
                if (EWcorr .and. (abs(x - 125.0D0) .le. 5.0D0)) then
                    call interpolate_tabletype1(x, XSSM(12), 8, interpol)
                end if
            end if
        else
            interpol = badvalue
        end if

        XS_lhc13_tH_schan_SM = interpol

    end function XS_lhc13_tH_schan_SM

    !******************************************************
    subroutine check_range(coll, Mh, rangeok, badvalue, strict)
        !******************************************************
        implicit none
        character(LEN=5), intent(in) :: coll ! coll should be the same as the elements of
        ! collider in S95tables.f90
        double precision, intent(in) :: Mh
        logical :: rangeok
        double precision :: badvalue
        logical, optional :: strict

        rangeok = .True.
        if (.not. (Mh .gt. 0.0D0)) then !in case Mh is NaN
            rangeok = .False.
        else
            select case (coll)
            case ('TEV  ')
                if (Mh .lt. tevXS_SM_functions_xmin) then
                    rangeok = .False.
                elseif (Mh .gt. tevXS_SM_functions_xmax) then
                    rangeok = .False.
                end if
            case ('LHC7 ')
                if (Mh .lt. lhc7XS_SM_functions_xmin) then
                    rangeok = .False.
                elseif (Mh .gt. lhc7XS_SM_functions_xmax) then
                    rangeok = .False.
                end if
            case ('LHC8 ')
                if (Mh .lt. lhc8XS_SM_functions_xmin) then
                    rangeok = .False.
                elseif (Mh .gt. lhc8XS_SM_functions_xmax) then
                    rangeok = .False.
                end if
            case ('LHC13 ')
                if (Mh .lt. lhc13XS_SM_functions_xmin) then
                    rangeok = .False.
                elseif (Mh .gt. lhc13XS_SM_functions_xmax) then
                    rangeok = .False.
                end if
            case default
                stop 'problem in subroutine check_range'
            end select
        end if

        badvalue = 0.0D0
        if (present(strict)) then
            if (strict) then
                badvalue = -1.0D0
                if (.not. rangeok) then
!       write(*,*)'Warning: Higgs mass is outside valid range for the SM cross section functions'
                end if
            end if
        end if

    end subroutine check_range

    !******************************************************
    function XS_tev_bg_Hb_SM(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_tev_bg_Hb_SM
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        logical, optional :: strict

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 1.0D3*tev_cs_bg_Hb_SM(x) !convert from pb to fb
        else
            func = badvalue
        end if

        XS_tev_bg_Hb_SM = func

    end function XS_tev_bg_Hb_SM
    !******************************************************
    function XS_tev_bg_Hb_c1_SM(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_tev_bg_Hb_c1_SM
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        logical, optional :: strict

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 1.0D3*tev_cs_bg_Hb_c1_SM(x) !convert from pb to fb
        else
            func = badvalue
        end if

        XS_tev_bg_Hb_c1_SM = func

    end function XS_tev_bg_Hb_c1_SM
    !******************************************************
    function XS_tev_bg_Hb_c2_SM(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_tev_bg_Hb_c2_SM
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        logical, optional :: strict

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 1.0D3*tev_cs_bg_Hb_c2_SM(x) !convert from pb to fb
        else
            func = badvalue
        end if

        XS_tev_bg_Hb_c2_SM = func

    end function XS_tev_bg_Hb_c2_SM
    !******************************************************
    function XS_tev_bg_Hb_c3_SM(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_tev_bg_Hb_c3_SM
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        logical, optional :: strict

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 1.0D3*SMCS_tev_bg_Hb_c3(x) !convert from pb to fb
        else
            func = badvalue
        end if

        XS_tev_bg_Hb_c3_SM = func

    end function XS_tev_bg_Hb_c3_SM
    !******************************************************
    function XS_tev_bg_Hb_c4_SM(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_tev_bg_Hb_c4_SM
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        logical, optional :: strict

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 1.0D3*tev_cs_bg_Hb_c4_SM(x) !convert from pb to fb
        else
            func = badvalue
        end if

        XS_tev_bg_Hb_c4_SM = func

    end function XS_tev_bg_Hb_c4_SM
    !******************************************************
    function XS_tev_HW_SM(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_tev_HW_SM
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2
        logical, optional :: strict

        a0 = 5.7514105496046D0
        a0p5 = -0.375021739545092D0
        a1 = 0.0049451487167627D0
        a2 = -3.77008582179264D-06

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_tev_HW_SM = func

    end function XS_tev_HW_SM
    !******************************************************
    function XS_tev_HZ_SM(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_tev_HZ_SM
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2
        logical, optional :: strict

        a0 = 5.29935340004443D0
        a0p5 = -0.351677660532052D0
        a1 = 0.0047848452802514D0
        a2 = -3.82425969474559D-06

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_tev_HZ_SM = func

    end function XS_tev_HZ_SM
    !******************************************************
    !function XS_tev_gg_H_SM(x,strict)
    !******************************************************
    ! implicit none
    ! double precision :: XS_tev_gg_H_SM
    ! double precision, intent(in) :: x
    ! logical :: rangeok
    ! double precision :: func,badvalue
    ! double precision :: a0,a0p5,a1,a2
    ! logical,optional :: strict

    ! a0 = 5.59682783597183D0
    ! a0p5 = -0.244216706673437D0
    ! a1 = 0.000365613425058581D0
    ! a2 = 2.66122261164927D-06

    ! call check_range('TEV  ',x,rangeok,badvalue,strict)
    ! if(rangeok)then
    !   func=10.0D0**(a0+a0p5*x**0.5D0+a1*x+a2*x**2.0D0)
    ! else
    !   func=badvalue
    ! endif

    ! XS_tev_gg_H_SM=  func

    !end function XS_tev_gg_H_SM
    !******************************************************
    function XS_tev_gg_H_SM(x, strict)
        !******************************************************
        !Updated by TS on 31/03/2011, result given in fb
        implicit none
        double precision :: XS_tev_gg_H_SM
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2
        logical, optional :: strict

        a0 = 2.82844783978179
        a0p5 = -0.238895314316816
        a1 = -0.00244189137753305
        a2 = 7.90070235250398e-06

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 10.0D0**3.0D0*10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_tev_gg_H_SM = func

    end function XS_tev_gg_H_SM
    !******************************************************
    function XS_tev_gg_H_SM_9713(x, strict)
        !******************************************************
        ! from CDF note 9713, D0 Note 5889
        ! note: need to check valdity outside 100<x<200

        implicit none
        double precision :: XS_tev_gg_H_SM_9713
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2
        logical, optional :: strict

        a0 = 5.85040646662332D0
        a0p5 = -0.289955377784879D0
        a1 = 0.00367931930924978D0
        a2 = -5.18285806787161D-06

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if ((x .lt. 100.0D0) .or. (x .gt. 200.0D0)) then
            !stop 'function XS_gg_H_SM_9713: need to check validity at this MH'
            write (*, *) 'WARNING: function XS_tev_gg_H_SM_9713: need to check validity at this MH'
        end if

        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_tev_gg_H_SM_9713 = func

    end function XS_tev_gg_H_SM_9713
    !******************************************************
    function XS_tev_gg_H_SM_9674(x, strict)
        !******************************************************
        ! from CDF note 9674
        ! note: need to check valdity outside 100<x<200

        implicit none
        double precision :: XS_tev_gg_H_SM_9674
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2
        logical, optional :: strict

        a0 = 5.46563745525111D0
        a0p5 = -0.25740914779426D0
        a1 = 0.00426592493420152D0
        a2 = -9.15606785912482D-06

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if ((x .lt. 100.0D0) .or. (x .gt. 200.0D0)) then
            !stop 'function XS_gg_H_SM_9674: need to check validity at this MH'
            write (*, *) 'WARNING: function XS_gg_H_SM_9674: need to check validity at this MH'
        end if

        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_tev_gg_H_SM_9674 = func

    end function XS_tev_gg_H_SM_9674
    !******************************************************
    function XS_tev_bb_H_SM(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_tev_bb_H_SM
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2
        logical, optional :: strict

        a0 = 5.41583328209568D0
        a0p5 = -0.453323023285831D0
        a1 = 0.00514220061294974D0
        a2 = -3.31488355831377D-06

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_tev_bb_H_SM = func

    end function XS_tev_bb_H_SM
    !******************************************************
    function XS_tev_vbf_SM(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_tev_vbf_SM
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2
        logical, optional :: strict

        a0 = 3.03330688577339D0
        a0p5 = -0.061167148821396D0
        a1 = -0.00424395931917914D0
        a2 = 7.67964289500027D-08

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_tev_vbf_SM = func

    end function XS_tev_vbf_SM
    !******************************************************
    function XS_tev_ttH_SM(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_tev_ttH_SM
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2
        logical, optional :: strict

        a0 = 1.23241191811843D0
        a0p5 = 0.188533306634442D0
        a1 = -0.0240486573108739D0
        a2 = 1.90098085776576D-05

        call check_range('TEV  ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_tev_ttH_SM = func

    end function XS_tev_ttH_SM
    !******************************************************
    function LEPHiggsstrahlung_XS_SM(sqrts, MH)
        !using eq.4.18 in arXiv:hep-ph/0503172 (Abdelhak Djouadi)
        !*****************************************************
        use usefulbits, only: MZ, MW, GF, pi
        implicit none
        double precision :: LEPHiggsstrahlung_XS_SM
        double precision, intent(in) :: sqrts, MH
        double precision :: ae, ve !Z charges of the electron
        double precision :: SW2
        double precision :: lambda !two-particle phase space function
        double precision :: coeff
        double precision :: s, MW2, MZ2, MH2

        s = sqrts**2.0D0
        MH2 = MH**2.0D0
        MW2 = MW**2.0D0
        MZ2 = MZ**2.0D0
        SW2 = 1.0D0 - MW2/MZ2

        ae = -1.0D0
        ve = -1.0D0 + 4.0D0*SW2

        lambda = (1.0D0 - MH2/s - MZ2/s)**2.0D0 &
                 - 4.0D0*MH2*MZ2/s**2.0D0

        coeff = GF**2.0D0*MZ**4.0D0/(96.0D0*pi)*(ae**2.0D0 + ve**2.0D0)

        LEPHiggsstrahlung_XS_SM = coeff/s*sqrt(lambda) &
                                  *(lambda + 12.0D0*MZ2/s) &
                                  /(1.0d0 - MZ2/s)**2.0D0

    end function LEPHiggsstrahlung_XS_SM

    !******************************************************
    ! FUNCTIONS FOR LHC AT 7 TEV
    ! nb: These functions are in units of pb
    !******************************************************
    !******************************************************
    function XS_lhc7_gg_H_SM_old(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_lhc7_gg_H_SM_old
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2, b1, b2, b3, b4, b5, c1, c2, c3, c4, c5
        logical, optional :: strict

        a0 = 2.78261222779432D0
        a0p5 = -0.392196551818852D0
        a1 = 0.0117978237757204D0
        a2 = -4.17151874265905D-06
        b1 = -6496.34228398077D0
        b2 = 174.334182737679D0
        b3 = 96.344419701078D0
        b4 = 351.731389836777D0
        b5 = 41.8042207045728D0
        c1 = 1378.60118731267D0
        c2 = 331.890749316436D0
        c3 = 427.044291881834D0
        c4 = 395.248606977478D0
        c5 = -31.7761947614136D0

        call check_range('LHC7 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0 &
                            + b1*exp(-(x - b2)**2.0D0/(b3**2.0D0))/((x - b4)**2.0D0 + b5**2.0D0) &
                            + c1*exp(-(x - c2)**2.0D0/(c3**2.0D0))/((x - c4) + c5**2.0D0))
        else
            func = badvalue
        end if

        XS_lhc7_gg_H_SM_old = func

    end function XS_lhc7_gg_H_SM_old

    !******************************************************
    function XS_lhc7_bb_H_SM_old(x, strict)
        !******************************************************
        !* fit to single Higgs production via b b-bar annihilation
        !* for a 7 TeV pp collider (NNLO QCD).
        !* Numbers generated with bbh@nnlo v. 1.3 (PDF: MSTW 2008 NNLO)
        !* with input parameters according to arXiv:1101.0593 [hep-ph].
        !******************************************************
        !* lhc7_cs_bbH_SM : CS in pikobarn
        !* x : Higgs mass in GeV
        !* fit: valid in range [70:1020], deviations from data table below 0.03%
        !* 28/4/2011, Oliver Brein (revised: 29/4/2011)
        !******************************
        implicit none
        double precision :: XS_lhc7_bb_H_SM_old
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        logical, optional :: strict
        double precision :: i1, j1, k1, a1, b1, c1, d1, e1, f1, g1, h1

        i1 = 118393.552970347d0
        j1 = -8500.14886364116d0
        k1 = 263.791637006274d0
        a1 = -0.686328023297912d0
        b1 = -0.0263560546043822d0
        c1 = 4.25891594291875d-05
        d1 = -6.72674484878268d-08
        e1 = 7.68476123865973d-11
        f1 = -5.76921139630906d-14
        g1 = 2.52072437882796d-17
        h1 = -4.83311237805624d-21

        call check_range('LHC7 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = exp(i1/x**3 + j1/x**2 + k1/x + a1 + b1*x + c1*x**2 &
                       + d1*x**3 + e1*x**4 + f1*x**5 + g1*x**6 + h1*x**7)
        else
            func = badvalue
        end if

        XS_lhc7_bb_H_SM_old = func

    end function XS_lhc7_bb_H_SM_old
    !******************************************************
    function XS_lhc7_HW_SM_old(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_lhc7_HW_SM_old
        double precision, intent(in) :: x
        double precision :: xtemp
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2
        logical, optional :: strict

        a0 = 3.47925709357706D0
        a0p5 = -0.405519201979233D0
        a1 = 0.006675415284311D0
        a2 = -1.66890554788541D-06

        if (x .gt. 305.0D0) then !function is not valid at these masses
            xtemp = 1.0D9
        else
            xtemp = x
        end if

        call check_range('LHC7 ', xtemp, rangeok, badvalue, strict)
        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_lhc7_HW_SM_old = func

    end function XS_lhc7_HW_SM_old
    !******************************************************
    function XS_lhc7_HZ_SM_old(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_lhc7_HZ_SM_old
        double precision, intent(in) :: x
        double precision :: xtemp
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2
        logical, optional :: strict

        a0 = 2.98356567605733D0
        a0p5 = -0.381566481668429D0
        a1 = 0.00666517818082496D0
        a2 = -3.40355207948873D-06

        if (x .gt. 305.0D0) then !function is not valid at these masses
            xtemp = 1.0D9
        else
            xtemp = x
        end if

        call check_range('LHC7 ', xtemp, rangeok, badvalue, strict)
        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_lhc7_HZ_SM_old = func

    end function XS_lhc7_HZ_SM_old
    !******************************************************
    function XS_lhc7_vbf_SM_old(x, strict)
        !******************************************************
        implicit none
        double precision :: XS_lhc7_vbf_SM_old
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2
        logical, optional :: strict

        a0 = 1.05101126849124D0
        a0p5 = -0.0781389982071239D0
        a1 = -0.000788771622392916D0
        a2 = 2.55014215205304D-07

        call check_range('LHC7 ', x, rangeok, badvalue, strict)
        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_lhc7_vbf_SM_old = func

    end function XS_lhc7_vbf_SM_old
    !******************************************************
    function XS_lhc7_ttH_SM_func(x, strict)
        ! Fit to YR3 numbers within m<= 300 GeV regime! Extrapolation beyond 300 GeV
        ! without any guarantees (but looks reasonable).
        !******************************************************
        implicit none
        double precision :: XS_lhc7_ttH_SM_func
        double precision, intent(in) :: x
        double precision :: xtemp
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2
        logical, optional :: strict

        a0 = 1.30235892285854D0
        a0p5 = -0.160563741042278D0
        a1 = -0.00582434890060432D0
        a2 = 1.00116051386356D-06

!   if(x.gt.305.0D0)then !function is not valid at these masses
!    xtemp=1.0D9
!   else
        xtemp = x
!   endif

        call check_range('LHC7 ', xtemp, rangeok, badvalue, strict)
        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_lhc7_ttH_SM_func = func

    end function XS_lhc7_ttH_SM_func
    !******************************************************

    !******************************************************
    ! FUNCTIONS FOR LHC AT 8 TEV
    ! nb: These functions are in units of pb
    !******************************************************
    function XS_lhc8_gg_H_SM_old(x, strict)
        !******************************************************
        ! Update (15/09/2014, TS): New numbers from YR3 in mass
        ! range [80:1000]. Calculated cross section within [60:80]
        ! with Grazzini's online calculator:
        ! http://theory.fi.infn.it/cgi-bin/higgsres.pl
        ! Subtracted 1.5% from result to approximate NLO EW corrections.
        ! Fit function smoothly continues outside valid mass range of
        ! [60:1000], showing no strange artifacts.
        !******************************************************
        implicit none
        double precision :: XS_lhc8_gg_H_SM_old
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2, b1, b2, b3, b4, b5, c1, c2, c3, c4, c5
        logical, optional :: strict

        call check_range('LHC8 ', x, rangeok, badvalue, strict)

        a0 = 4.80460446867791D0
        a0p5 = -0.561291516848061D0
        a1 = 0.0258452560273618D0
        a2 = -3.07840530611877D-05
        b1 = 375.717055681801D0
        b2 = 241.08386658847D0
        b3 = 35.7144202378D0
        b4 = 310.124404457984D0
        b5 = 10.2091442738781D0
        c1 = 36478.6666876259D0
        c2 = 497.980740873626D0
        c3 = 468.290091682881D0
        c4 = 361.880403983753D0
        c5 = 103.685654678909D0

!  a0   =  3.56707207858078D0
!  a0p5 = -0.25129459795463D0
!  a1   =  0.00433097626519D0
!  a2   = -1.45688652134851D-06
!  b1   = 2770.27394599256D0
!  b2   = 468.519089926562D0
!  b3   = 190.55026272631D0
!  b4   = 379.385111182956D0
!  b5   =  98.6497066533147D0
!  c1   = 494.614733048339D0
!  c2   = 522.274297446605D0
!  c3   = 221.208787555184D0
!  c4   = 381.687044343604D0
!  c5   = -43.5526250947967D0

        if (rangeok) then
!    func=10.0D0**(a0+a0p5*x**0.5D0+a1*x+a2*x**2.0D0 &
!        & +b1*exp(-(x-b2)**2.0D0/(b3**2.0D0))/((x-b4)**2.0D0+b5**2.0D0) &
!        & +c1*exp(-(x-c2)**2.0D0/(c3**2.0D0))/((x-c4)+c5**2.0D0))
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0 &
                            + b1*exp(-(x - b2)**2.0D0/(b3**2.0D0))/((x - b4)**2.0D0 + b5**2.0D0)) &
                   + c1*exp(-(x - c2)**2.0D0/(c3**2.0D0))/((x - c4)**2.0D0 + c5**2.0D0)

        else
            func = badvalue
        end if

        XS_lhc8_gg_H_SM_old = func

    end function XS_lhc8_gg_H_SM_old

!******************************************************
    function XS_lhc8_bb_H_SM_old(x, strict)
        !******************************************************
        !* fit to single Higgs production via b b-bar annihilation
        !* for a 8 TeV pp collider (NNLO QCD).
        !* Numbers generated with bbh@nnlo v. 1.3 (PDF: MSTW 2008 NNLO)
        !* with input parameters according to arXiv:1101.0593 [hep-ph].
        !******************************************************
        !* lhc8_cs_bbH_SM : CS in pikobarn
        !* x : Higgs mass in GeV
        !* fit: valid in range [70:1020], deviations from data table below 0.03%
        !* Implemented 5/9/2012 by Oscar Stl (cross sections from Oliver Brein)
        !*******************************************************
        !* Update (16/9/2014, TS): Updated numbers to those of the YR3.
        !* Numbers available for [80, 400] GeV, fit function looks reasonable
        !* for mass range [40, 1100] GeV.
        !*******************************************************
        implicit none
        double precision :: XS_lhc8_bb_H_SM_old
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        logical, optional :: strict
!  double precision :: i1,j1,k1,a1,b1,c1,d1,e1,f1,g1,h1
        double precision :: am1, a0, a0p5, a1, a2

        am1 = 7.28346175088007
        a0 = 2.55313341835946
        a0p5 = -0.34809898410672
        a1 = 0.00377731392689874
        a2 = 1.29486435520287e-07

!        i1 = 179990.036887499D0
!        j1 = -10984.6196406673D0
!        k1 = 303.68366721968D0
!        a1 = -0.86167068733782D0
!        b1 = -0.0236609848244952D0
!        c1 = 3.50207214193607D-05
!        d1 = -5.12839831227492D-08
!        e1 = 5.5011300483384D-11
!        f1 = -3.91883451027439D-14
!        g1 = 1.6391896198688D-17
!        h1 = -3.03114011105266D-21

        call check_range('LHC8 ', x, rangeok, badvalue, strict)
        if (rangeok) then
!    func=exp( i1/x**3+j1/x**2+k1/x+a1+b1*x+c1*x**2 &
!          &   +d1*x**3+e1*x**4+f1*x**5+g1*x**6+h1*x**7  )
            func = 10.0D0**(am1/x + a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0)
        else
            func = badvalue
        end if

        XS_lhc8_bb_H_SM_old = func

    end function XS_lhc8_bb_H_SM_old
    !******************************************************

    !******************************************************
    function XS_lhc8_HW_SM_old(x, strict)
        !******************************************************
        ! Update (16/09/2014, TS): New fit to updated numbers
        ! of the YR3. Underlying numbers in mass range [80,400]
        ! GeV, fit extends reasonably to mass range [20,450] GeV.
        !******************************************************
        implicit none
        double precision :: XS_lhc8_HW_SM_old
        double precision, intent(in) :: x
        double precision :: xtemp
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2, a3, a4
        logical, optional :: strict

!  if(x.gt.305.0D0)then !function is not valid at these masses
        if (x .gt. 450.0D0) then !function is not valid at these masses
            xtemp = 1.0D9
        else
            xtemp = x
        end if

!  a0   =  3.43597459323194D0
!  a0p5 = -0.381906179194475D0
!  a1   =  0.00543972777300234D0
!  a2   = -3.66506941121493D-07

        a0 = 3.01235666515895D0
        a0p5 = -0.312688353936888D0
        a1 = 0.00200726253208301D0
        a2 = -2.79580100881394D-06
        a3 = 2.34931925792847D-08
        a4 = -3.27458891365096D-11

        call check_range('LHC8 ', xtemp, rangeok, badvalue, strict)
        if (rangeok) then
!    func=10.0D0**(a0+a0p5*x**0.5D0+a1*x+a2*x**2.0D0)
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0 + a3*x**3.0D0 + a4*x**4.0D0)
        else
            func = badvalue
        end if

        XS_lhc8_HW_SM_old = func

    end function XS_lhc8_HW_SM_old
    !******************************************************
    function XS_lhc8_HZ_SM_old(x, strict)
        !******************************************************
        ! Update (16/09/2014, TS): New fit to updated numbers
        ! of the YR3. Underlying numbers in mass range [80,400]
        ! GeV, fit extends reasonably to mass range [20,450] GeV.
        !******************************************************
        implicit none
        double precision :: XS_lhc8_HZ_SM_old
        double precision, intent(in) :: x
        double precision :: xtemp
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2, a3, a4
        logical, optional :: strict

!  if(x.gt.305.0D0)then !function is not valid at these masses
        if (x .gt. 450.0D0) then !function is not valid at these masses
            xtemp = 1.0D9
        else
            xtemp = x
        end if

!  a0   =  3.03485415368548D0
!  a0p5 = -0.376931854913315D0
!  a1   =  0.00660445384856735D0
!  a2   = -3.30648728092992D-06

        a0 = 3.02650891463869D0
        a0p5 = -0.404715124216486D0
        a1 = 0.00945378328194135D0
        a2 = -1.16534141280507D-05
        a3 = 1.301339006803D-08
        a4 = -7.2364967643456D-12

        call check_range('LHC8 ', xtemp, rangeok, badvalue, strict)
        if (rangeok) then
!    func=10.0D0**(a0+a0p5*x**0.5D0+a1*x+a2*x**2.0D0)
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0 + a3*x**3.0D0 + a4*x**4.0D0)
        else
            func = badvalue
        end if

        XS_lhc8_HZ_SM_old = func

    end function XS_lhc8_HZ_SM_old

    !******************************************************
    function XS_lhc8_vbf_SM_old(x, strict)
        !******************************************************
        ! Update (16/09/2014): Updated to new numbers from YR3,
        ! for mass range [80.,1000.] GeV. Fit extends reasonable
        ! to mass range [20.,1200.] GeV.
        !******************************************************
        implicit none
        double precision :: XS_lhc8_vbf_SM_old
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2, a3
        logical, optional :: strict

        a0 = 0.997895751135864D0
        a0p5 = -0.0745047859662863D0
        a1 = -0.000594800111789716D0
        a2 = -2.43125249201783D-07
        a3 = 3.10301024559832D-10

!  a0   =  1.01415063256363D0
!  a0p5 = -0.0596858887887809D0
!  a1   = -0.00124307978950821D0
!  a2   =  4.90033650462757D-07

        call check_range('LHC8 ', x, rangeok, badvalue, strict)

        if (rangeok) then
!    func=10.0D0**(a0+a0p5*x**0.5D0+a1*x+a2*x**2.0D0)
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0 + a3*x**3.0D0)

        else
            func = badvalue
        end if

        XS_lhc8_vbf_SM_old = func

    end function XS_lhc8_vbf_SM_old

    !******************************************************
    function XS_lhc8_ttH_SM_func(x, strict)
        !******************************************************
        ! Update (23/05/2016, TS): New fit to updated numbers
        ! of the YR4. Applies to mass range [10:3000] GeV.
        !******************************************************
        implicit none
        double precision :: XS_lhc8_ttH_SM_func
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2, a4
        logical, optional :: strict

! NEW FIT (TS 05/23/2016)
        a0 = 1.88824756082929D0
        a0p5 = -0.30033317767335D0
        a1 = 0.00454929867367946D0
        a2 = -9.97582598986152D-07
        a4 = 2.10862937419158D-14

        call check_range('LHC8 ', x, rangeok, badvalue, strict)

        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0 + a4*x**4.0D0)
        else
            func = badvalue
        end if

        XS_lhc8_ttH_SM_func = func

    end function XS_lhc8_ttH_SM_func
    !******************************************************
    function XS_lhc13_ttH_SM_func(x, strict)
        !******************************************************
        ! Fit to the YR4 numbers. Applies to mass range [10:3000] GeV.
        !******************************************************
        implicit none
        double precision :: XS_lhc13_ttH_SM_func
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2, a4
        logical, optional :: strict

! NEW FIT (TS 05/23/2016)

        a0 = 2.4009372068545D0
        a0p5 = -0.300654427433046D0
        a1 = 0.00523830095923711D0
        a2 = -1.08583378582902D-06
        a4 = 2.84226058210467D-14

        call check_range('LHC13', x, rangeok, badvalue, strict)

        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0 + a4*x**4.0D0)
        else
            func = badvalue
        end if

        XS_lhc13_ttH_SM_func = func

    end function XS_lhc13_ttH_SM_func
    !******************************************************
    function XS_lhc13_tH_tchan_SM_func(x, strict)
        !******************************************************
        ! Fit to the YR4 numbers. Applies to mass range [10:3000] GeV.
        !******************************************************
        implicit none
        double precision :: XS_lhc13_tH_tchan_SM_func
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2, am1, am0p5
        logical, optional :: strict

        a0 = -3.42127049995874D0
        a0p5 = 0.102402204465032D0
        am0p5 = 19.9858075733198D0
        am1 = -29.3740767399399D0
        a1 = -0.00295972728178451D0
        a2 = 1.99209027708294D-07

        call check_range('LHC13', x, rangeok, badvalue, strict)

        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0 + am0p5*x**(-0.5D0) + am1/x)
        else
            func = badvalue
        end if

        XS_lhc13_tH_tchan_SM_func = func

    end function XS_lhc13_tH_tchan_SM_func
    !******************************************************
    function XS_lhc13_tH_schan_SM_func(x, strict)
        !******************************************************
        ! Fit to the YR4 numbers. Applies to mass range [10:3000] GeV.
        !******************************************************
        implicit none
        double precision :: XS_lhc13_tH_schan_SM_func
        double precision, intent(in) :: x
        logical :: rangeok
        double precision :: func, badvalue
        double precision :: a0, a0p5, a1, a2, am1, am0p5
        logical, optional :: strict

        a0 = -1.14164085109118
        a0p5 = -0.170205776743063
        am0p5 = 4.55733135420734
        am1 = -7.66862942732554
        a1 = 0.00127845448464183
        a2 = -1.97339760404829e-07

        call check_range('LHC13', x, rangeok, badvalue, strict)

        if (rangeok) then
            func = 10.0D0**(a0 + a0p5*x**0.5D0 + a1*x + a2*x**2.0D0 + am0p5*x**(-0.5D0) + am1/x)
        else
            func = badvalue
        end if

        XS_lhc13_tH_schan_SM_func = func

    end function XS_lhc13_tH_schan_SM_func

    double precision function tev_cs_bg_Hb_SM(x)
        !******************************************************
        !* Fit for sigma(pp-bar -> b g -> H b) in pikobarn as a function of Higgs mass in GeV
        !* However, sigma(pp-bar -> b g -> H b)+sigma(pp-bar -> b-bar g -> H b-bar) is
        !* needed here. Hence, the factor of 2 below.
        !*
        !* PDF used: MRST NNLO 2006
        !* K-factors used: none.
        !* However, used: a) scale choice MU_R=MU_F=M_h/4
        !*                b) 1-loop running bottom mass instead of pole mass
        !* This resembles pretty closely the NLO result of Maltoni et al. (hep-ph/0204093)
        !******************************************************
        ! x : Higgs mass in GeV.
        ! fit: valid in range [10:400], deviations from data below 0.3%
        implicit none
        double precision x, a, b, c, d, e, f, g, h, i, j, k, log_tev_cs_bg_Hb

        i = 1123.83787799968
        j = -356.707392839726
        k = 45.9128876730515
        a = 1.6356919815081
        b = -0.0936888262673351
        c = 0.000517589926136613
        d = -2.60428788311317e-06
        e = 9.05347214042015e-09
        f = -1.99410338384936e-11
        g = 2.48409692520096e-14
        h = -1.32760959238599e-17
        log_tev_cs_bg_Hb = i/x**3 + j/x**2 + k/x + a + b*x + c*x**2 + d*x**3 + e*x**4 + f*x**5 + g*x**6 + h*x**7
        tev_cs_bg_Hb_SM = 2d0*exp(log_tev_cs_bg_Hb)

    end function

    double precision function tev_cs_bg_Hb_c4_SM(x)
        !******************************************************
        !* Fit for sigma(pp-bar -> b g -> H b) in pikobarn as a function of Higgs mass in GeV
        !* However, sigma(pp-bar -> b g -> H b)+sigma(pp-bar -> b-bar g -> H b-bar) is
        !* needed here. Hence, the factor of 2 below.
        !*
        !* PDF used: MSTW NNLO 2008
        !* K-factors used: none.
        !* However, used: a) scale choice MU_R=MU_F=M_h/4
        !*                b) 1-loop running bottom mass instead of pole mass
        !* This resembles pretty closely the NLO result of Maltoni et al. (hep-ph/0204093)
        !* cuts used: ptmin=12 GeV, etamax=5 (c4)
        !* /!\: using ptmin as low as 12 GeV may render the prediction less accurate
        !******************************************************
        !c x : Higgs mass
        !c fit: valid in range [10:400], deviations from data below 0.6%
        implicit none
        double precision a, b, c, d, e, f, g, h, i, j, k, x, log_tev_cs_bg_Hb_c4

        i = 858.031227860774d0
        j = -258.119990404928d0
        k = 27.1187184643582d0
        a = -0.228082879265122d0
        b = -0.0758457063398605d0
        c = 0.000321567763038373d0
        d = -1.28719909200427d-06
        e = 3.44247069068616d-09
        f = -5.5337665142955d-12
        g = 4.58899173696998d-15
        h = -1.3449829067125d-18

        log_tev_cs_bg_Hb_c4 = i/x**3 + j/x**2 + k/x + a + b*x + c*x**2 + d*x**3 + e*x**4 + f*x**5 + g*x**6 + h*x**7
        tev_cs_bg_Hb_c4_SM = 2d0*exp(log_tev_cs_bg_Hb_c4)

    end function

    double precision function SMCS_tev_bg_Hb_c3(x)
        !******************************************************
        !* Fit for sigma(pp-bar -> b g -> H b) in pikobarn as a function of Higgs mass in GeV
        !* However, sigma(pp-bar -> b g -> H b)+sigma(pp-bar -> b-bar g -> H b-bar) is
        !* needed here. Hence, the factor of 2 below.
        !*
        !* PDF used: MRST NNLO 2006
        !* K-factors used: none.
        !* However, used: a) scale choice MU_R=MU_F=M_h/4
        !*                b) 1-loop running bottom mass instead of pole mass
        !* This resembles pretty closely the NLO result of Maltoni et al. (hep-ph/0204093)
        !* cuts used: ptmin=15 GeV, etamax=2.5 (c3)
        !******************************************************
        !c x : Higgs mass
        !c fit: valid in range [10:400], deviations from data below 0.6%
        implicit none
        double precision a, b, c, d, e, f, g, h, i, j, k, x, log_tev_cs_bg_Hb_c3

        i = 975.922569925692
        j = -262.219528073721
        k = 23.4358421199538
        a = -0.827082997657741
        b = -0.0695990730309521
        c = 0.000294055015901147
        d = -1.22958624351404e-06
        e = 3.63264089688587e-09
        f = -6.84539813558712e-12
        g = 7.28039954882708e-15
        h = -3.29940845455953e-18

        log_tev_cs_bg_Hb_c3 = i/x**3 + j/x**2 + k/x + a + b*x + c*x**2 + d*x**3 + e*x**4 + f*x**5 + g*x**6 + h*x**7
        SMCS_tev_bg_Hb_c3 = 2d0*exp(log_tev_cs_bg_Hb_c3)
    end function

    double precision function tev_cs_bg_Hb_c1_SM(x)
        !******************************************************
        !* Fit for sigma(pp-bar -> b g -> H b) in pikobarn as a function of Higgs mass in GeV
        !* However, sigma(pp-bar -> b g -> H b)+sigma(pp-bar -> b-bar g -> H b-bar) is
        !* needed here. Hence, the factor of 2 below.
        !*
        !* PDF used: MRST NNLO 2006
        !* K-factors used: none.
        !* However, used: a) scale choice MU_R=MU_F=M_h/4
        !*                b) 1-loop running bottom mass instead of pole mass
        !* This resembles pretty closely the NLO result of Maltoni et al. (hep-ph/0204093)
        !* cuts used: ptmin=15 GeV, etamax=2 (c1)
        !******************************************************
        !c x : Higgs mass
        !c fit: valid in range [10:400], deviations from data below 0.6%
        implicit none
        double precision a, b, c, d, e, f, g, h, i, j, k, x, log_tev_cs_bg_Hb_c1

        i = 979.232120836288
        j = -264.696290260115
        k = 23.7789096288902
        a = -0.976837806470803
        b = -0.0694778939102754
        c = 0.000300026595336677
        d = -1.31248432594797e-06
        e = 4.11789388677158e-09
        f = -8.31929589817916e-12
        g = 9.55612036163061e-15
        h = -4.71205719524022e-18

        log_tev_cs_bg_Hb_c1 = i/x**3 + j/x**2 + k/x + a + b*x + c*x**2 + d*x**3 + e*x**4 + f*x**5 + g*x**6 + h*x**7
        tev_cs_bg_Hb_c1_SM = 2d0*exp(log_tev_cs_bg_Hb_c1)

    end function

    double precision function tev_cs_bg_Hb_c2_SM(x)
        !******************************************************
        !* Fit for sigma(pp-bar -> b g -> H b) in pikobarn as a function of Higgs mass in GeV
        !* However, sigma(pp-bar -> b g -> H b)+sigma(pp-bar -> b-bar g -> H b-bar) is
        !* needed here. Hence, the factor of 2 below.
        !*
        !* PDF used: MRST NNLO 2006
        !* K-factors used: none.
        !* However, used: a) scale choice MU_R=MU_F=M_h/4
        !*                b) 1-loop running bottom mass instead of pole mass
        !* This resembles pretty closely the NLO result of Maltoni et al. (hep-ph/0204093)
        !* cuts used: ptmin=20 GeV, etamax=2.5 (c2)
        !******************************************************
        !c x : Higgs mass
        !c fit: valid in range [10:400], deviations from data below 0.5%
        implicit none
        double precision a, b, c, d, e, f, g, h, i, j, k, x, log_tev_cs_bg_Hb_c2

        i = 834.839818583352
        j = -191.225997471594
        k = 11.7585430990651
        a = -1.19870317148684
        b = -0.0704359029295396
        c = 0.000329995529227224
        d = -1.56164857859755e-06
        e = 5.21024154218793e-09
        f = -1.10321498760019e-11
        g = 1.31618393769414e-14
        h = -6.7078954437179e-18

        log_tev_cs_bg_Hb_c2 = i/x**3 + j/x**2 + k/x + a + b*x + c*x**2 + d*x**3 + e*x**4 + f*x**5 + g*x**6 + h*x**7
        tev_cs_bg_Hb_c2_SM = 2d0*exp(log_tev_cs_bg_Hb_c2)

    end function

    subroutine testXSSM(M)
        implicit none
        double precision, intent(in) :: M

        if (M .gt. 0) continue ! silence unused variable warning

        if (.not. allocated(XSSM)) then
            write (*, *) 'XSSM has to be allocated by calling setup_XSSM from'
            write (*, *) 'the theory_XS_SM_functions module (as e.g. done in '
            write (*, *) 'initialize_HiggsBounds)'
            stop 'error (see standard output for more info)'
        end if

    end subroutine testXSSM

    function collider_name(collider)
        implicit none
        integer, intent(in) :: collider
        character(len=5) :: collider_name
        select case (collider)
        case (2)
            collider_name = 'TEV'
        case (7)
            collider_name = 'LHC7'
        case (8)
            collider_name = 'LHC8'
        case (13)
            collider_name = 'LHC13'
        case default
            write (*, *) 'invalid collider id ', collider
            stop 1
        end select
    end function

end module theory_XS_SM_functions
